# 网络与协议基础

## 1. 文档概述

本文档详细介绍了网络编程的基础理论知识，包括网络分层模型、基础协议、IP地址管理、网络传输机制以及字节序处理等核心概念。这些知识是进行网络编程的基础，为后续的套接字编程和高级网络应用开发奠定理论基础。

## 2. 网络分层模型

### 2.1 OSI七层模型

OSI（Open Systems Interconnection）七层模型是国际标准化组织（ISO）制定的网络通信标准，它将网络通信过程分为七个层次：

```
┌─────────────────────────────────────────────────────────────┐
│ 7. 应用层 (Application Layer)     │ HTTP, HTTPS, FTP, SMTP, DNS │
├─────────────────────────────────────────────────────────────┤
│ 6. 表示层 (Presentation Layer)   │ 数据加密、压缩、格式转换      │
├─────────────────────────────────────────────────────────────┤
│ 5. 会话层 (Session Layer)        │ 建立、管理、终止会话         │
├─────────────────────────────────────────────────────────────┤
│ 4. 传输层 (Transport Layer)      │ TCP, UDP, SCTP             │
├─────────────────────────────────────────────────────────────┤
│ 3. 网络层 (Network Layer)        │ IP, ICMP, ARP, 路由协议     │
├─────────────────────────────────────────────────────────────┤
│ 2. 数据链路层 (Data Link Layer)  │ Ethernet, WiFi, PPP        │
├─────────────────────────────────────────────────────────────┤
│ 1. 物理层 (Physical Layer)       │ 电缆、光纤、无线电波        │
└─────────────────────────────────────────────────────────────┘
```

#### 2.1.1 各层详细说明

**第1层 - 物理层（Physical Layer）**
- **功能**：定义电气、机械、功能和过程规范
- **职责**：比特流的传输
- **设备**：网卡、集线器、中继器
- **协议**：RS-232、V.35、RJ-45

**第2层 - 数据链路层（Data Link Layer）**
- **功能**：在物理层基础上提供可靠的数据传输
- **职责**：帧同步、差错控制、流量控制
- **设备**：交换机、网桥
- **协议**：Ethernet、WiFi、PPP、HDLC

**第3层 - 网络层（Network Layer）**
- **功能**：提供端到端的数据传输路径
- **职责**：路由选择、拥塞控制、网络互连
- **设备**：路由器
- **协议**：IP、ICMP、ARP、BGP、OSPF

**第4层 - 传输层（Transport Layer）**
- **功能**：提供端到端的可靠数据传输
- **职责**：连接管理、流量控制、差错恢复
- **协议**：TCP、UDP、SCTP

**第5层 - 会话层（Session Layer）**
- **功能**：建立、管理和终止会话
- **职责**：会话控制、同步点管理
- **协议**：RPC、SQL、NetBIOS

**第6层 - 表示层（Presentation Layer）**
- **功能**：数据格式转换、加密解密
- **职责**：数据压缩、加密、格式转换
- **协议**：SSL/TLS、JPEG、MPEG

**第7层 - 应用层（Application Layer）**
- **功能**：为用户应用程序提供网络服务
- **职责**：用户接口、网络服务
- **协议**：HTTP、HTTPS、FTP、SMTP、DNS

### 2.2 TCP/IP模型

TCP/IP模型是实际网络通信中广泛使用的四层模型：

```
┌─────────────────────────────────────────────────────────────┐
│ 应用层 (Application Layer)        │ HTTP, HTTPS, FTP, SMTP, DNS │
├─────────────────────────────────────────────────────────────┤
│ 传输层 (Transport Layer)          │ TCP, UDP, SCTP             │
├─────────────────────────────────────────────────────────────┤
│ 网络层 (Internet Layer)           │ IP, ICMP, ARP, 路由协议     │
├─────────────────────────────────────────────────────────────┤
│ 网络接口层 (Network Interface)    │ Ethernet, WiFi, PPP        │
└─────────────────────────────────────────────────────────────┘
```

#### 2.2.1 TCP/IP与OSI模型对比

| OSI模型 | TCP/IP模型 | 主要协议 | 功能描述 |
|---------|------------|----------|----------|
| 应用层 | 应用层 | HTTP, HTTPS, FTP, SMTP, DNS | 用户应用程序接口 |
| 表示层 | 应用层 | SSL/TLS, JPEG, MPEG | 数据格式转换、加密 |
| 会话层 | 应用层 | RPC, SQL, NetBIOS | 会话管理 |
| 传输层 | 传输层 | TCP, UDP, SCTP | 端到端数据传输 |
| 网络层 | 网络层 | IP, ICMP, ARP | 路由和寻址 |
| 数据链路层 | 网络接口层 | Ethernet, WiFi, PPP | 帧传输 |
| 物理层 | 网络接口层 | 电缆、光纤、无线电波 | 比特传输 |

### 2.3 数据封装与解封装

数据在网络传输过程中会经历封装和解封装的过程：

#### 2.3.1 数据封装过程（发送端）

```
应用数据
    ↓
[应用层] + 应用层头部 → 应用层数据
    ↓
[传输层] + TCP/UDP头部 → 段（Segment）
    ↓
[网络层] + IP头部 → 数据包（Packet）
    ↓
[数据链路层] + 帧头部 + 帧尾部 → 帧（Frame）
    ↓
[物理层] → 比特流
```

#### 2.3.2 数据解封装过程（接收端）

```
比特流
    ↓
[物理层] → 帧（Frame）
    ↓
[数据链路层] 移除帧头部和尾部 → 数据包（Packet）
    ↓
[网络层] 移除IP头部 → 段（Segment）
    ↓
[传输层] 移除TCP/UDP头部 → 应用数据
    ↓
[应用层] 处理应用数据
```

## 3. 基础网络协议

### 3.1 数据链路层协议

#### 3.1.1 Ethernet（以太网）

Ethernet是最广泛使用的局域网技术，采用CSMA/CD（载波监听多路访问/冲突检测）机制。

**Ethernet帧结构：**

```
┌─────────────┬─────────────┬─────────────┬─────────────┬─────────────┬─────────────┐
│ 前导码      │ 帧开始符    │ 目标MAC     │ 源MAC       │ 类型/长度   │ 数据        │
│ (7字节)     │ (1字节)     │ (6字节)     │ (6字节)     │ (2字节)     │ (46-1500字节)│
├─────────────┼─────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 10101010... │ 10101011    │ 00:11:22:33:44:55 │ aa:bb:cc:dd:ee:ff │ 0x0800      │ IP数据包    │
└─────────────┴─────────────┴─────────────┴─────────────┴─────────────┴─────────────┘
```

**MAC地址格式：**
- 48位（6字节）地址
- 格式：XX:XX:XX:XX:XX:XX（十六进制）
- 前3字节：厂商标识（OUI）
- 后3字节：设备标识

**CSMA/CD机制：**
1. 载波监听：发送前监听信道是否空闲
2. 多路访问：多个设备共享同一信道
3. 冲突检测：检测到冲突时停止发送
4. 退避算法：随机等待后重试

#### 3.1.2 ARP（地址解析协议）

ARP用于将IP地址解析为MAC地址，实现网络层到数据链路层的地址映射。

**ARP工作原理：**

```
主机A (192.168.1.10) 想与主机B (192.168.1.20) 通信

1. 主机A检查ARP缓存表
2. 如果找不到主机B的MAC地址，发送ARP请求：
   - 目标MAC：FF:FF:FF:FF:FF:FF (广播)
   - 目标IP：192.168.1.20
3. 主机B收到ARP请求，回复ARP应答：
   - 包含自己的MAC地址
4. 主机A更新ARP缓存表
```

**ARP报文格式：**

```
┌─────────────┬─────────────┬─────────────┬─────────────┬─────────────┬─────────────┐
│ 硬件类型    │ 协议类型    │ 硬件地址长度│ 协议地址长度│ 操作码      │ 发送方MAC   │
│ (2字节)     │ (2字节)     │ (1字节)     │ (1字节)     │ (2字节)     │ (6字节)     │
├─────────────┼─────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 发送方IP    │ 目标MAC     │ 目标IP      │             │             │             │
│ (4字节)     │ (6字节)     │ (4字节)     │             │             │             │
└─────────────┴─────────────┴─────────────┴─────────────┴─────────────┴─────────────┘
```

### 3.2 网络层协议

#### 3.2.1 IPv4（Internet Protocol Version 4）

IPv4是当前互联网使用的主要网络层协议，提供无连接、不可靠的数据报服务。

**IPv4头部格式：**

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
┌─────────────────────────────────────────────────────────────┐
│版本│IHL│服务类型│          总长度                            │
├─────────────────────────────────────────────────────────────┤
│          标识符              │标志│      片偏移              │
├─────────────────────────────────────────────────────────────┤
│  生存时间  │    协议        │          头部校验和            │
├─────────────────────────────────────────────────────────────┤
│                      源IP地址                               │
├─────────────────────────────────────────────────────────────┤
│                      目标IP地址                             │
├─────────────────────────────────────────────────────────────┤
│                    选项（可选）                             │
└─────────────────────────────────────────────────────────────┘
```

**各字段说明：**

| 字段 | 长度 | 说明 |
|------|------|------|
| 版本 | 4位 | IP版本号，IPv4为4 |
| IHL | 4位 | 头部长度，以4字节为单位 |
| 服务类型 | 8位 | 服务质量参数 |
| 总长度 | 16位 | 整个IP数据包长度 |
| 标识符 | 16位 | 用于分片重组 |
| 标志 | 3位 | 分片控制标志 |
| 片偏移 | 13位 | 分片在原始数据包中的位置 |
| 生存时间 | 8位 | TTL，防止数据包无限循环 |
| 协议 | 8位 | 上层协议类型（TCP=6, UDP=17） |
| 头部校验和 | 16位 | 头部校验和 |
| 源IP地址 | 32位 | 发送方IP地址 |
| 目标IP地址 | 32位 | 接收方IP地址 |

**IPv4地址分类：**

| 类别 | 地址范围 | 网络位 | 主机位 | 用途 |
|------|----------|--------|--------|------|
| A类 | 1.0.0.0 - 126.255.255.255 | 8位 | 24位 | 大型网络 |
| B类 | 128.0.0.0 - 191.255.255.255 | 16位 | 16位 | 中型网络 |
| C类 | 192.0.0.0 - 223.255.255.255 | 24位 | 8位 | 小型网络 |
| D类 | 224.0.0.0 - 239.255.255.255 | - | - | 多播地址 |
| E类 | 240.0.0.0 - 255.255.255.255 | - | - | 保留地址 |

#### 3.2.2 IPv6（Internet Protocol Version 6）

IPv6是IPv4的下一代协议，解决了IPv4地址不足的问题。

**IPv6地址格式：**
- 128位地址长度
- 8组，每组4个十六进制数字
- 格式：2001:0db8:85a3:0000:0000:8a2e:0370:7334
- 简化表示：2001:db8:85a3::8a2e:370:7334

**IPv6地址类型：**

| 类型 | 前缀 | 用途 | 示例 |
|------|------|------|------|
| 单播 | 2000::/3 | 全球单播地址 | 2001:db8::1 |
| 链路本地 | fe80::/10 | 链路本地通信 | fe80::1 |
| 唯一本地 | fc00::/7 | 私有网络 | fd00::1 |
| 多播 | ff00::/8 | 多播通信 | ff02::1 |
| 任播 | 从单播地址分配 | 任播服务 | 2001:db8::1 |

**IPv6头部格式：**

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
┌─────────────────────────────────────────────────────────────┐
│版本│ 流量类别  │              流标签                        │
├─────────────────────────────────────────────────────────────┤
│          载荷长度          │  下一个头部  │   跳数限制      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│                    源地址（128位）                          │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│                    目标地址（128位）                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 3.2.3 ICMP（Internet Control Message Protocol）

ICMP用于网络层错误报告和网络诊断。

**ICMP报文类型：**

| 类型 | 代码 | 说明 | 用途 |
|------|------|------|------|
| 0 | 0 | Echo Reply | ping响应 |
| 3 | 0-15 | Destination Unreachable | 目标不可达 |
| 4 | 0 | Source Quench | 源站抑制 |
| 5 | 0-3 | Redirect | 重定向 |
| 8 | 0 | Echo Request | ping请求 |
| 11 | 0-1 | Time Exceeded | 超时 |
| 12 | 0-1 | Parameter Problem | 参数问题 |

**ICMP报文格式：**

```
┌─────────────────────────────────────────────────────────────┐
│    类型     │    代码     │           校验和                │
├─────────────────────────────────────────────────────────────┤
│                    未使用（全0）                           │
├─────────────────────────────────────────────────────────────┤
│                    数据部分                                │
└─────────────────────────────────────────────────────────────┘
```

**常用ICMP工具：**
- **ping**：测试网络连通性
- **traceroute**：跟踪数据包路径
- **pathping**：Windows下的路径跟踪工具

### 3.3 传输层协议

#### 3.3.1 TCP（Transmission Control Protocol）

TCP提供面向连接、可靠的字节流传输服务。

**TCP特点：**
- **面向连接**：通信前需要建立连接
- **可靠传输**：通过确认机制保证数据完整
- **流量控制**：通过滑动窗口控制发送速度
- **拥塞控制**：通过拥塞窗口避免网络拥塞
- **全双工**：支持双向数据传输

**TCP连接管理：**

**三次握手（建立连接）：**
```
客户端                    服务器
    │                        │
    │ ──── SYN ────────────→ │
    │                        │
    │ ←── SYN+ACK ────────── │
    │                        │
    │ ──── ACK ────────────→ │
    │                        │
    │    连接建立完成        │
```

**四次挥手（关闭连接）：**
```
客户端                    服务器
    │                        │
    │ ──── FIN ────────────→ │
    │                        │
    │ ←── ACK ────────────── │
    │                        │
    │ ←── FIN ────────────── │
    │                        │
    │ ──── ACK ────────────→ │
    │                        │
    │    连接关闭完成        │
```

**TCP头部格式：**

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
┌─────────────────────────────────────────────────────────────┐
│         源端口号            │         目标端口号            │
├─────────────────────────────────────────────────────────────┤
│                       序列号                                │
├─────────────────────────────────────────────────────────────┤
│                     确认号                                  │
├─────────────────────────────────────────────────────────────┤
│ 数据偏移│ 保留 │U│A│P│R│S│F│           窗口大小            │
├─────────────────────────────────────────────────────────────┤
│           校验和            │         紧急指针              │
├─────────────────────────────────────────────────────────────┤
│                    选项（可选）                             │
└─────────────────────────────────────────────────────────────┘
```

#### 3.3.2 UDP（User Datagram Protocol）

UDP提供无连接、不可靠的数据报传输服务。

**UDP特点：**
- **无连接**：发送数据前不需要建立连接
- **不可靠**：不保证数据到达和顺序
- **高效**：头部开销小，传输效率高
- **简单**：协议实现简单

**UDP头部格式：**

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
┌─────────────────────────────────────────────────────────────┐
│         源端口号            │         目标端口号            │
├─────────────────────────────────────────────────────────────┤
│           长度              │           校验和              │
└─────────────────────────────────────────────────────────────┘
```

**UDP vs TCP对比：**

| 特性 | TCP | UDP |
|------|-----|-----|
| 连接性 | 面向连接 | 无连接 |
| 可靠性 | 可靠 | 不可靠 |
| 传输方式 | 字节流 | 数据报 |
| 头部开销 | 20字节 | 8字节 |
| 传输效率 | 较低 | 较高 |
| 适用场景 | 文件传输、Web浏览 | 实时通信、DNS查询 |

#### 3.3.3 SCTP（Stream Control Transmission Protocol）

SCTP是相对较新的传输层协议，结合了TCP和UDP的优点。

**SCTP特点：**
- **多流传输**：支持多个独立的数据流
- **部分可靠性**：可选择可靠或不可靠传输
- **消息边界**：保持应用层消息边界
- **多宿支持**：支持多个网络接口

### 3.4 应用层协议

#### 3.4.1 DNS（Domain Name System）

DNS将域名解析为IP地址，是互联网的基础服务。

**DNS记录类型：**

| 记录类型 | 说明 | 示例 |
|----------|------|------|
| A | IPv4地址记录 | www.example.com → 192.168.1.1 |
| AAAA | IPv6地址记录 | www.example.com → 2001:db8::1 |
| CNAME | 别名记录 | www.example.com → example.com |
| MX | 邮件交换记录 | example.com → mail.example.com |
| NS | 名称服务器记录 | example.com → ns1.example.com |
| PTR | 反向解析记录 | 1.1.168.192.in-addr.arpa → www.example.com |
| TXT | 文本记录 | 用于验证和配置 |

**DNS查询过程：**

```
1. 用户输入域名：www.example.com
2. 本地DNS缓存查询
3. 根域名服务器查询
4. 顶级域名服务器查询（.com）
5. 权威域名服务器查询
6. 返回IP地址：192.168.1.1
```

#### 3.4.2 HTTP/HTTPS

HTTP是Web通信的基础协议，HTTPS是HTTP的安全版本。

**HTTP请求格式：**

```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
Connection: keep-alive

[请求体]
```

**HTTP响应格式：**

```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1024
Server: Apache/2.4.41

<html>
<head><title>Example</title></head>
<body>Hello World!</body>
</html>
```

**HTTPS特点：**
- 使用TLS/SSL加密
- 默认端口443
- 提供数据加密和身份验证

#### 3.4.3 TLS（Transport Layer Security）

TLS提供传输层安全服务，确保数据在传输过程中的机密性和完整性。

**TLS握手过程：**

```
客户端                    服务器
    │                        │
    │ ──── ClientHello ────→ │
    │                        │
    │ ←── ServerHello ────── │
    │ ←── Certificate ────── │
    │ ←── ServerKeyExchange │
    │ ←── ServerHelloDone ── │
    │                        │
    │ ──── ClientKeyExchange │
    │ ──── ChangeCipherSpec  │
    │ ──── Finished ────────→│
    │                        │
    │ ←── ChangeCipherSpec ─ │
    │ ←── Finished ───────── │
    │                        │
    │    加密通信开始        │
```

#### 3.4.4 DHCP（Dynamic Host Configuration Protocol）

DHCP自动分配IP地址和其他网络配置参数。

**DHCP工作过程：**

```
客户端                    服务器
    │                        │
    │ ──── DHCP Discover ──→ │
    │                        │
    │ ←── DHCP Offer ─────── │
    │                        │
    │ ──── DHCP Request ────→│
    │                        │
    │ ←── DHCP ACK ───────── │
    │                        │
    │    获得IP配置          │
```

## 4. IP地址与子网划分

### 4.1 IPv4地址管理

#### 4.1.1 地址表示方法

**点分十进制表示法：**
- 32位地址分为4个8位组
- 每组用十进制表示（0-255）
- 用点号分隔：192.168.1.1

**二进制表示法：**
- 32位二进制数
- 192.168.1.1 = 11000000.10101000.00000001.00000001

#### 4.1.2 私网地址段

RFC 1918定义了三个私网地址段：

| 地址段 | 子网掩码 | 地址数量 | 用途 |
|--------|----------|----------|------|
| 10.0.0.0/8 | 255.0.0.0 | 16,777,216 | 大型企业网络 |
| 172.16.0.0/12 | 255.240.0.0 | 1,048,576 | 中型企业网络 |
| 192.168.0.0/16 | 255.255.0.0 | 65,536 | 小型企业/家庭网络 |

#### 4.1.3 CIDR（无类域间路由）

CIDR使用斜杠表示法表示网络前缀长度。

**CIDR表示法：**
- 格式：IP地址/前缀长度
- 192.168.1.0/24 表示前24位是网络位
- 子网掩码：255.255.255.0

**常见CIDR块：**

| CIDR | 子网掩码 | 主机数量 | 用途 |
|------|----------|----------|------|
| /8 | 255.0.0.0 | 16,777,216 | A类网络 |
| /16 | 255.255.0.0 | 65,536 | B类网络 |
| /24 | 255.255.255.0 | 256 | C类网络 |
| /25 | 255.255.255.128 | 128 | 子网划分 |
| /26 | 255.255.255.192 | 64 | 子网划分 |
| /27 | 255.255.255.224 | 32 | 子网划分 |
| /28 | 255.255.255.240 | 16 | 子网划分 |
| /30 | 255.255.255.252 | 4 | 点对点连接 |

#### 4.1.4 子网划分示例

**示例：将192.168.1.0/24划分为4个子网**

```
原始网络：192.168.1.0/24
子网掩码：255.255.255.0
主机数量：256个

子网划分：
子网1：192.168.1.0/26    (192.168.1.0   - 192.168.1.63)   64个地址
子网2：192.168.1.64/26   (192.168.1.64  - 192.168.1.127)  64个地址
子网3：192.168.1.128/26  (192.168.1.128 - 192.168.1.191)  64个地址
子网4：192.168.1.192/26  (192.168.1.192 - 192.168.1.255)  64个地址
```

### 4.2 IPv6地址管理

#### 4.2.1 地址表示方法

**完整表示法：**
```
2001:0db8:85a3:0000:0000:8a2e:0370:7334
```

**简化表示法：**
```
2001:db8:85a3::8a2e:370:7334
```

**简化规则：**
- 前导零可以省略
- 连续的零可以用::表示（只能使用一次）
- 地址末尾的零不能省略

#### 4.2.2 地址类型详解

**单播地址（Unicast）：**
- 全球单播地址：2000::/3
- 链路本地地址：fe80::/10
- 唯一本地地址：fc00::/7

**多播地址（Multicast）：**
- 前缀：ff00::/8
- 范围：ff0x::/16（x表示范围）
- 常用多播地址：
  - ff02::1：所有节点
  - ff02::2：所有路由器
  - ff02::1:ffxx:xxxx：请求节点多播

**任播地址（Anycast）：**
- 从单播地址空间分配
- 多个节点共享同一地址
- 数据包发送到最近的节点

### 4.3 路由选择

#### 4.3.1 路由表结构

**路由表条目：**

| 字段 | 说明 | 示例 |
|------|------|------|
| 目标网络 | 目标网络地址 | 192.168.1.0/24 |
| 子网掩码 | 网络掩码 | 255.255.255.0 |
| 下一跳 | 下一跳路由器地址 | 192.168.0.1 |
| 接口 | 出站接口 | eth0 |
| 度量值 | 路由成本 | 1 |
| 类型 | 路由类型 | 直连/静态/动态 |

#### 4.3.2 路由选择算法

**最长前缀匹配：**
- 选择子网掩码最长的路由
- 更具体的路由优先于通用路由

**示例：**
```
路由表：
192.168.0.0/16    → 192.168.0.1    (通用路由)
192.168.1.0/24    → 192.168.1.1    (具体路由)

目标地址：192.168.1.100
选择：192.168.1.0/24 (更具体)
```

## 5. 网络传输机制

### 5.1 MTU（最大传输单元）

#### 5.1.1 MTU概念

MTU是数据链路层能够传输的最大数据包大小，不包括帧头和帧尾。

**常见网络介质的MTU：**

| 网络类型 | MTU | 说明 |
|----------|-----|------|
| Ethernet | 1500字节 | 标准以太网 |
| PPPoE | 1492字节 | 减去PPP头部 |
| 802.11 WiFi | 1500字节 | 无线以太网 |
| 令牌环 | 4464字节 | IBM令牌环 |
| FDDI | 4352字节 | 光纤分布式数据接口 |

#### 5.1.2 分片与重组

当IP数据包超过链路MTU时，需要进行分片。

**分片过程：**
1. 检查数据包大小是否超过MTU
2. 如果超过，将数据包分成多个片段
3. 每个片段添加IP头部
4. 设置分片标志和偏移量
5. 在目标主机进行重组

**分片头部字段：**
- **标识符**：标识属于同一数据包的所有片段
- **标志**：MF（More Fragments）标志
- **片偏移**：片段在原始数据包中的位置

**分片示例：**
```
原始数据包：4000字节
MTU：1500字节
IP头部：20字节
数据部分：3980字节

分片1：1480字节数据 + 20字节头部 = 1500字节
分片2：1480字节数据 + 20字节头部 = 1500字节  
分片3：1020字节数据 + 20字节头部 = 1040字节
```

#### 5.1.3 Path MTU Discovery（PMTUD）

PMTUD动态发现路径上的最小MTU，避免分片。

**PMTUD过程：**
1. 发送方发送DF（Don't Fragment）标志的数据包
2. 如果数据包超过某段链路的MTU，路由器返回ICMP错误
3. 发送方根据ICMP错误调整数据包大小
4. 重复过程直到找到合适的MTU

**ICMP错误类型：**
- Type 3, Code 4：Fragmentation Needed and DF Set
- 包含下一跳MTU信息

### 5.2 端口与服务

#### 5.2.1 端口概念

端口是传输层用于标识不同应用程序的16位数字（0-65535）。

**端口分类：**

| 端口范围 | 类型 | 说明 |
|----------|------|------|
| 0-1023 | Well-known ports | 系统保留端口 |
| 1024-49151 | Registered ports | 注册端口 |
| 49152-65535 | Dynamic ports | 动态端口 |

#### 5.2.2 知名端口（Well-known Ports）

**常用端口列表：**

| 端口 | 协议 | 服务 | 说明 |
|------|------|------|------|
| 20 | TCP | FTP-DATA | FTP数据端口 |
| 21 | TCP | FTP | FTP控制端口 |
| 22 | TCP | SSH | 安全Shell |
| 23 | TCP | Telnet | 远程登录 |
| 25 | TCP | SMTP | 邮件传输 |
| 53 | UDP/TCP | DNS | 域名解析 |
| 67 | UDP | DHCP | DHCP服务器 |
| 68 | UDP | DHCP | DHCP客户端 |
| 80 | TCP | HTTP | Web服务 |
| 110 | TCP | POP3 | 邮件接收 |
| 143 | TCP | IMAP | 邮件访问 |
| 443 | TCP | HTTPS | 安全Web服务 |
| 993 | TCP | IMAPS | 安全IMAP |
| 995 | TCP | POP3S | 安全POP3 |

#### 5.2.3 端口扫描与安全

**端口扫描技术：**
- **TCP SYN扫描**：发送SYN包，根据响应判断端口状态
- **TCP Connect扫描**：尝试建立完整连接
- **UDP扫描**：发送UDP包，根据ICMP响应判断
- **NULL扫描**：发送无标志的TCP包

**安全措施：**
- 防火墙过滤
- 端口访问控制
- 服务最小化原则
- 定期端口扫描检测

## 6. 字节序与数据转换

### 6.1 字节序（Endianness）

#### 6.1.1 字节序概念

字节序是指多字节数据在内存中的存储顺序。

**大端序（Big-Endian）：**
- 高位字节存储在低地址
- 网络字节序采用大端序
- 人类阅读习惯（从左到右）

**小端序（Little-Endian）：**
- 低位字节存储在低地址
- x86/x64架构采用小端序
- 计算机处理习惯

**字节序示例：**
```
数值：0x12345678

大端序存储：
地址：  0x1000  0x1001  0x1002  0x1003
数据：    12      34      56      78

小端序存储：
地址：  0x1000  0x1001  0x1002  0x1003
数据：    78      56      34      12
```

#### 6.1.2 字节序对网络编程的影响

**问题：**
- 不同架构的主机字节序可能不同
- 网络传输必须使用统一的字节序
- 直接传输多字节数据会导致数据错误

**解决方案：**
- 网络传输使用大端序（网络字节序）
- 发送前转换为网络字节序
- 接收后转换为主机字节序

### 6.2 字节序转换函数

#### 6.2.1 基本转换函数

**16位整数转换：**
```c
#include <arpa/inet.h>

// 主机字节序 → 网络字节序
uint16_t htons(uint16_t hostshort);

// 网络字节序 → 主机字节序  
uint16_t ntohs(uint16_t netshort);
```

**32位整数转换：**
```c
// 主机字节序 → 网络字节序
uint32_t htonl(uint32_t hostlong);

// 网络字节序 → 主机字节序
uint32_t ntohl(uint32_t netlong);
```

**函数命名规则：**
- `h`：host（主机）
- `n`：network（网络）
- `s`：short（16位）
- `l`：long（32位）

#### 6.2.2 使用示例

**发送数据：**
```c
uint16_t port = 8080;
uint32_t ip = 0xC0A80101; // 192.168.1.1

// 转换为网络字节序
uint16_t net_port = htons(port);
uint32_t net_ip = htonl(ip);

// 发送数据
send(sock, &net_port, sizeof(net_port), 0);
send(sock, &net_ip, sizeof(net_ip), 0);
```

**接收数据：**
```c
uint16_t net_port;
uint32_t net_ip;

// 接收数据
recv(sock, &net_port, sizeof(net_port), 0);
recv(sock, &net_ip, sizeof(net_ip), 0);

// 转换为主机字节序
uint16_t port = ntohs(net_port);
uint32_t ip = ntohl(net_ip);
```

#### 6.2.3 注意事项

**常见错误：**
- 忘记进行字节序转换
- 对单字节数据使用转换函数
- 对字符串使用转换函数

**最佳实践：**
- 所有多字节数据都要转换
- 使用统一的字节序约定
- 添加字节序检查代码

### 6.3 IP地址转换函数

#### 6.3.1 现代转换函数

**inet_pton() - 字符串转二进制：**
```c
#include <arpa/inet.h>

int inet_pton(int af, const char *src, void *dst);
```

**inet_ntop() - 二进制转字符串：**
```c
const char *inet_ntop(int af, const void *src, 
                     char *dst, socklen_t size);
```

**参数说明：**
- `af`：地址族（AF_INET for IPv4, AF_INET6 for IPv6）
- `src`：源地址（字符串或二进制）
- `dst`：目标地址（二进制或字符串）
- `size`：目标缓冲区大小

**使用示例：**
```c
// IPv4地址转换
char ip_str[] = "192.168.1.1";
struct in_addr addr;

// 字符串 → 二进制
if (inet_pton(AF_INET, ip_str, &addr) == 1) {
    printf("转换成功: 0x%x\n", addr.s_addr);
}

// 二进制 → 字符串
char ip_str2[INET_ADDRSTRLEN];
if (inet_ntop(AF_INET, &addr, ip_str2, INET_ADDRSTRLEN) != NULL) {
    printf("IP地址: %s\n", ip_str2);
}
```

#### 6.3.2 历史转换函数

**inet_aton() - 字符串转二进制：**
```c
#include <arpa/inet.h>

int inet_aton(const char *cp, struct in_addr *inp);
```

**inet_addr() - 字符串转二进制：**
```c
in_addr_t inet_addr(const char *cp);
```

**inet_ntoa() - 二进制转字符串：**
```c
char *inet_ntoa(struct in_addr in);
```

#### 6.3.3 函数对比

| 函数 | 优点 | 缺点 | 线程安全 |
|------|------|------|----------|
| inet_pton/ntop | 支持IPv6、线程安全 | 较新 | 是 |
| inet_aton | 简单易用 | 仅支持IPv4 | 是 |
| inet_addr | 简单易用 | 仅支持IPv4、错误处理差 | 是 |
| inet_ntoa | 简单易用 | 仅支持IPv4、非线程安全 | 否 |

**推荐使用：**
- 新代码使用 `inet_pton()` 和 `inet_ntop()`
- 支持IPv6和IPv4
- 线程安全
- 更好的错误处理

## 7. 实践练习

### 7.1 网络分析工具

**Wireshark使用：**
- 抓包分析网络协议
- 查看数据包详细信息
- 分析协议交互过程

**tcpdump使用：**
```bash
# 抓取所有网络包
tcpdump -i any

# 抓取特定主机的包
tcpdump host 192.168.1.1

# 抓取特定端口的包
tcpdump port 80

# 抓取TCP包
tcpdump tcp
```

### 7.2 网络配置命令

**Linux网络配置：**
```bash
# 查看网络接口
ip addr show

# 配置IP地址
ip addr add 192.168.1.100/24 dev eth0

# 查看路由表
ip route show

# 添加路由
ip route add 192.168.2.0/24 via 192.168.1.1

# 查看ARP表
ip neigh show

# 测试连通性
ping 192.168.1.1

# 跟踪路由
traceroute 8.8.8.8
```

### 7.3 编程实践

**字节序检测程序：**
```c
#include <stdio.h>
#include <stdint.h>

int main() {
    uint16_t test = 0x1234;
    uint8_t *ptr = (uint8_t*)&test;
    
    if (ptr[0] == 0x12) {
        printf("大端序\n");
    } else if (ptr[0] == 0x34) {
        printf("小端序\n");
    }
    
    return 0;
}
```

**IP地址转换程序：**
```c
#include <stdio.h>
#include <arpa/inet.h>

int main() {
    char ip_str[] = "192.168.1.1";
    struct in_addr addr;
    
    if (inet_pton(AF_INET, ip_str, &addr) == 1) {
        printf("IP地址: %s\n", ip_str);
        printf("二进制: 0x%x\n", addr.s_addr);
        
        char ip_str2[INET_ADDRSTRLEN];
        if (inet_ntop(AF_INET, &addr, ip_str2, INET_ADDRSTRLEN) != NULL) {
            printf("转换回字符串: %s\n", ip_str2);
        }
    }
    
    return 0;
}
```

## 8. 总结

网络与协议基础是网络编程的基石，掌握这些知识对于后续的套接字编程和高级网络应用开发至关重要。本章涵盖了：

1. **网络分层模型**：理解OSI七层模型和TCP/IP四层模型
2. **基础协议**：掌握Ethernet、ARP、IP、TCP、UDP等核心协议
3. **地址管理**：学会IPv4/IPv6地址表示和子网划分
4. **传输机制**：理解MTU、分片、PMTUD等概念
5. **字节序处理**：掌握网络编程中的数据转换

这些基础知识为下一阶段的套接字编程奠定了坚实的理论基础。在实际编程中，要特别注意字节序转换和错误处理，确保程序的正确性和健壮性。

---

**文档版本**：v1.0  
**创建时间**：2025年09月30日 16:04:30 CST  
**最后更新**：2025年09月30日 16:04:30 CST  
**维护者**：Gamma
