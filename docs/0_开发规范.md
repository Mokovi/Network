# 开发规范

## 1. 代码风格规范

### 1.1 命名规范

#### 1.1.1 类名
- 使用**PascalCase**命名法
- 类名应该是名词，清晰表达类的职责
- 接口类命名约定：
  - 使用`I`前缀（如`ILogOutput`）：便于识别纯虚接口
- 设计模式类命名约定：
  - **工厂模式**：使用`Factory`后缀（如`LogOutputFactory`、`ConnectionFactory`）
  - **建造者模式**：使用`Builder`后缀（如`HttpRequestBuilder`、`ConfigBuilder`）
  - **单例模式**：使用`Manager`或`Singleton`后缀（如`LogManager`、`ConfigManager`） 
  - **策略模式**：使用`Strategy`后缀（如`SortStrategy`、`CompressionStrategy`）
  - **装饰器模式**：使用`Decorator`后缀（如`LogDecorator`、`StreamDecorator`）
  - **适配器模式**：使用`Adapter`后缀（如`LegacyAdapter`、`ProtocolAdapter`）
  - **观察者模式**：使用`Observer`、`Subject`、`Publisher`、`Subscriber`等后缀
  - **命令模式**：使用`Command`后缀（如`SaveCommand`、`DeleteCommand`）
  - **状态模式**：使用`State`后缀（如`ConnectionState`、`GameState`）
  - **模板方法模式**：使用`Template`后缀（如`DataProcessorTemplate`）

#### 1.1.2 函数名
- 使用**camelCase**命名法
- 函数名应该是动词或动词短语 如`getStats`
- 布尔函数以`is`、`has`、`can`等开头

#### 1.1.3 变量名
- 使用**camelCase**命名法
- 成员变量以`m`开头,静态成员变量以`s`开头
- 常量使用**UPPER_SNAKE_CASE**

#### 1.1.4 文件名
- 使用**camelCase**命名法
- 头文件扩展名约定：
  - 普通头文件：`.h`或`.hpp`（推荐`.hpp`，明确表示C++头文件）
  - 模板实现文件：`.tpp`或`.ipp`（避免ODR问题）
- 源文件使用`.cpp`扩展名
- 测试文件以`test`开头
- 示例文件以`example`或`demo`开头

#### 1.1.5 命名空间
- 使用**camelCase**命名法
- 避免过深的嵌套

### 1.2 设计模式命名规范

#### 1.2.1 设计模式识别原则
- **明确性**：类名必须清楚表明其使用的设计模式
- **一致性**：相同设计模式的类使用相同的命名约定
- **可读性**：命名应该让其他开发者一眼就能识别设计模式

#### 1.2.2 常见设计模式命名模板
```cpp
// 工厂模式
class LogOutputFactory;           // 工厂类
class ILogOutput;                 // 产品接口
class FileLogOutput;              // 具体产品

// 建造者模式
class HttpRequestBuilder;         // 建造者类
class HttpRequest;                // 产品类

// 策略模式
class SortStrategy;               // 策略接口
class QuickSortStrategy;          // 具体策略
class MergeSortStrategy;          // 具体策略

// 装饰器模式
class ILogOutput;                 // 组件接口
class AbstractLogOutput;          // 抽象组件
class LogDecorator;               // 装饰器基类
class TimestampDecorator;         // 具体装饰器

// 观察者模式
class Subject;                    // 主题类
class Observer;                   // 观察者接口
class LogSubject;                 // 具体主题
class LogObserver;                // 具体观察者

// 单例模式
class LogManager;                 // 管理器类（单例）
class ConfigManager;              // 管理器类（单例）

// 命令模式
class Command;                    // 命令接口
class SaveCommand;                // 具体命令
class DeleteCommand;              // 具体命令

// 状态模式
class ConnectionState;            // 状态接口
class ConnectedState;             // 具体状态
class DisconnectedState;          // 具体状态

// 模板方法模式
class DataProcessorTemplate;      // 模板类
class AbstractDataProcessor;      // 抽象基类
```

### 1.3 格式规范

#### 1.3.1 缩进和空格
- 使用4个空格进行缩进，不使用Tab
- 操作符前后加空格
- 逗号后加空格
- 函数参数列表过长时换行对齐

#### 1.3.2 大括号风格
- 使用**K&R风格**（开括号不换行）
- 控制语句必须使用大括号，即使只有一条语句

#### 1.3.3 行长度
- 每行代码不超过120个字符
- 超过时进行适当的换行和缩进

### 1.4 类型规范

#### 1.4.1 类型别名
- 使用`using`而不是`typedef`
- 类型别名使用**PascalCase**命名法（与类名保持一致）

#### 1.4.2 现代C++习惯
- **智能指针使用**：优先使用`std::unique_ptr`，需要共享所有权时使用`std::shared_ptr`，避免使用裸指针
- **空指针**：使用`nullptr`而非`NULL`或`0`
- **函数重写**：重写虚函数时必须加`override`，必要时加`final`
- **异常安全**：公共API上标注`noexcept`（若不抛异常）
- **常量表达式**：尽量使用`constexpr`/`consteval`
- **拷贝控制**：遵循Rule of Zero/Five，明确`=delete`、`=default`、`noexcept`要求

#### 1.4.3 移动语义
- **优先使用移动**：对于可移动的对象，优先使用移动语义而非拷贝
- **右值引用**：使用`&&`标记右值引用参数，支持移动语义
- **std::move**：在适当的地方使用`std::move`显式移动
- **移动构造函数**：为资源管理类实现移动构造函数和移动赋值运算符
- **返回值优化**：依赖编译器的返回值优化，避免不必要的拷贝

#### 1.4.4 类型安全
- **强类型**：使用强类型而非弱类型，避免类型转换错误
- **enum class**：优先使用`enum class`而非普通`enum`
- **auto关键字**：合理使用`auto`，但避免过度使用导致类型不明确
- **类型推导**：使用`decltype`和`decltype(auto)`进行类型推导

## 2. 头文件规范

### 2.1 Header Guard
- 使用`#pragma once`（简单且广泛支持）

### 2.2 Include顺序和规则
- 严格按照以下顺序包含头文件：
  1. 当前模块头文件
  2. 本项目其他头文件
  3. 第三方库头文件
  4. 标准库头文件
- 采用"包含你所使用的"（Include What You Use）原则
- 每个分组之间用空行分隔

### 2.3 前向声明
- **优先使用前向声明**：在头文件中优先使用前向声明而非包含完整头文件
- **减少编译依赖**：通过前向声明减少编译时间和依赖关系
- **PIMPL模式**：对于复杂类，考虑使用PIMPL模式隐藏实现细节

## 3. 注释规范

### 3.1 主要规范

- **头文件**: 每个源文件和头文件都必须包含标准的Doxygen文件头注释，包括`@file`、`@brief`、`@author`、`@date`、`@version`、`@details`、`@see`、`@since`等标签。
- **类注释**: 每个类都必须有详细的Doxygen注释说明，包括`@brief`、`@details`、`@note`、`@warning`、`@see`、`@since`、`@example`等标签。
- **函数注释**: 公共接口函数必须有详细的Doxygen注释，包括`@brief`、`@details`、`@param[in/out/inout]`、`@return`、`@throws`、`@note`、`@warning`、`@pre`、`@post`、`@see`、`@since`等标签。
- **枚举和常量**: 枚举和常量必须有Doxygen注释，使用`///<`行尾注释格式。
- **成员变量**: 重要的成员变量应该有Doxygen注释，说明其用途和特性。

### 3.2 标签说明

#### 3.2.1 必需标签
- `@brief`: 简短描述（一行）
- `@details`: 详细描述（多行）
- `@param[in/out/inout]`: 参数说明
- `@return`: 返回值说明
- `@since`: 版本信息

#### 3.2.2 可选标签
- `@note`: 重要说明
- `@warning`: 警告信息
- `@pre`: 前置条件
- `@post`: 后置条件
- `@throws`: 异常说明
- `@see`: 相关引用
- `@example`: 使用示例
- `@tparam`: 模板参数（模板类专用）

#### 3.2.3 特殊注释
- `///<`: 行尾注释，用于简单说明
- `//!`: 行尾注释的另一种形式
- `/*!`: 块注释的开始

## 4. 异常和错误处理规范

### 4.1 异常使用策略
- **何时抛异常**：库边界和公共API抛异常处理不可恢复的错误，内部循环/高性能路径返回错误码
- **异常安全等级**：basic guarantee（基本保证）、strong guarantee（强保证）、no-throw guarantee（不抛异常保证）
- **noexcept使用**：析构函数应当`noexcept`

### 4.2 错误码
- 对于可恢复的错误，使用错误码
- 定义清晰的错误码枚举
- 提供错误码到错误信息的映射

### 4.3 错误处理最佳实践
- **RAII原则**：使用RAII管理资源，确保异常安全
- **错误传播**：使用`std::expected`（C++23）或`std::optional`处理可能失败的操作
- **错误日志**：记录详细的错误信息，包括上下文和堆栈信息

## 5. 并发和线程安全规范

### 5.1 线程安全设计指南
- **锁的粒度**：锁的粒度要尽可能小，避免长时间持有锁
- **原子变量**：简单操作使用`std::atomic`，复杂操作使用锁
- **条件变量**：使用`std::condition_variable`进行线程同步
- **避免死锁**：固定锁的获取顺序，使用`try_lock`避免长时间等待，避免在持有锁期间进行阻塞操作

### 5.2 线程注解规范
- 在注释中使用`@threadsafe`标注线程安全的函数
- 使用`@not_threadsafe`标注非线程安全的函数
- 考虑使用clang Thread Safety Analysis进行静态分析

## 6. 性能规范

### 6.1 内存管理
- 避免频繁的内存分配和释放
- 使用对象池管理频繁创建的对象
- 合理使用移动语义
- **内存对齐**：注意数据结构的内存对齐，提高缓存效率
- **内存池**：对于频繁分配的小对象，使用内存池技术

### 6.2 编译优化
- **内联函数**：合理使用`inline`关键字
- **常量折叠**：使用`constexpr`和`consteval`进行编译时计算
- **链接时优化**：启用LTO（Link Time Optimization）
- **Profile Guided Optimization**：使用PGO优化热点代码

## 7. 控制流规范

### 7.1 禁止使用的语句
- **goto语句**：严格禁止使用`goto`语句，使用结构化编程替代
- **setjmp/longjmp**：禁止使用非局部跳转
- **递归深度**：避免过深的递归调用，可能导致栈溢出

### 7.2 控制流最佳实践
- **早期返回**：使用早期返回减少嵌套层级
- **卫语句**：使用卫语句处理边界条件
- **循环优化**：使用范围for循环和算法替代传统for循环
- **条件简化**：简化复杂的条件表达式，提高可读性

## 8. CMake最佳实践
- **out-of-source构建**：构建目录与源码目录分离
- **精确依赖管理**：使用`INTERFACE`/`PUBLIC`/`PRIVATE`精确表明依赖关系
- **目标配置**：使用`target_include_directories`和`target_link_libraries`

## 9. 测试规范

### 9.1 测试覆盖率
- 每个公共接口都要有对应的单元测试
- 测试覆盖率不低于80%
- 使用Google Test框架

### 9.2 测试最佳实践
- **测试命名**：测试用例命名清晰，描述测试场景和期望结果
- **测试隔离**：每个测试用例独立，不依赖其他测试的执行结果
- **Mock对象**：使用Mock对象模拟外部依赖
- **性能测试**：包含性能基准测试，确保性能指标
- **边界测试**：测试边界条件和异常情况


## 10. 文档规范

### 10.1 文档分类
- **项目说明**: 项目简介、需求说明、技术栈、技术难点、技术指标
- **架构文档**: 系统整体架构、组件关系、项目目录，不写具体实现。
- **设计文档**: 具体模块的设计思路和实现方案
- **开发计划**: 具体到类的项目开发计划（以最小可运行产物 → 增量扩展 → 性能/可维护性增强为原则）
- **API文档**: 详细的接口说明和使用方法
- **部署文档**: 环境配置和部署步骤
- **用户手册**: 最终用户的使用指南，包括快速上手教程及FAQ和故障排除

### 10.2 文档维护规范
- **更新频率**: 每次代码变更后及时更新相关文档
- **版本控制**: 文档与代码版本保持一致
- **审查机制**: 建立文档审查流程，确保质量

## 11. README文档规范

### 11.1 文档结构规范

#### 11.1.1 必需章节
README.md必须包含以下章节，按顺序排列：
1. **项目徽章** - 显示项目状态、版本、平台等信息
2. **项目标题和简介** - 简洁的项目描述和特性概述
3. **核心特性** - 使用emoji图标突出主要功能
4. **系统架构** - 清晰的架构图和层次说明
5. **快速开始** - 环境要求、安装步骤、运行示例
6. **使用指南** - 基础用法、高级用法、配置选项
7. **项目结构** - 完整的目录树结构
8. **构建配置** - CMake选项、构建目标
9. **性能指标** - 基准测试结果和性能特点
10. **测试说明** - 测试运行方法和覆盖范围
11. **API文档** - 核心类和主要方法说明
12. **贡献指南** - 贡献方式和开发环境设置
13. **许可证信息** - 开源许可证类型
14. **致谢和联系** - 项目状态和联系方式

#### 11.1.2 可选章节
根据项目需要可添加：
- 更新日志
- 常见问题
- 故障排除
- 相关项目

### 11.2 内容规范

#### 11.2.1 项目徽章
- 使用Shields.io生成标准徽章
- 必须包含：C++版本、CMake版本、许可证、平台支持
- 徽章链接到相应的官方文档或项目页面

#### 11.2.2 项目简介
- 使用引用块格式（>）突出项目描述
- 第一段简洁说明项目用途
- 第二段描述技术特点和适用场景
- 使用emoji图标增强视觉效果

#### 11.2.3 核心特性
- 使用emoji图标（🚀✨🏗️等）分类特性
- 每个特性用粗体突出关键词
- 特性描述简洁明了，突出价值

#### 11.2.4 系统架构
- 使用ASCII艺术图或Mermaid图表
- 清晰展示系统层次结构
- 每层说明主要职责和组件

#### 11.2.5 快速开始
- 环境要求使用表格或列表格式
- 安装步骤使用编号列表
- 运行示例提供具体的命令和输出

#### 11.2.6 使用指南
- 基础用法提供完整的代码示例
- 高级用法展示复杂场景
- 配置选项使用代码块展示配置结构

#### 11.2.7 项目结构
- 使用树形结构展示目录
- 每个文件/目录添加注释说明用途
- 突出重要的配置文件和目录

#### 11.2.8 性能指标
- 使用表格展示测试结果
- 包含具体的数值和单位
- 说明测试环境和条件

#### 11.2.9 API文档
- 列出核心类和接口
- 提供主要方法的代码示例
- 说明参数、返回值和异常

### 11.3 格式规范

#### 11.3.1 标题层级
- 使用标准的Markdown标题层级（# ## ###）
- 主标题使用一级标题（#）
- 主要章节使用二级标题（##）
- 子章节使用三级标题（###）

#### 11.3.2 代码块
- 使用```标记代码块
- 指定语言类型（如cpp、bash、json）
- 重要代码添加注释说明

#### 11.3.3 列表格式
- 使用-标记无序列表
- 使用数字标记有序列表
- 嵌套列表使用适当的缩进

#### 11.3.4 表格格式
- 使用标准Markdown表格语法
- 表头使用粗体突出
- 数据对齐使用:符号

#### 11.3.5 链接和引用
- 使用相对路径引用项目内文件
- 外部链接使用完整URL
- 重要链接使用粗体突出


