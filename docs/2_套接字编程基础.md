# 套接字编程基础

## 1. 文档概述

本文档详细介绍了套接字编程的基础知识和实践技能，包括套接字概念、UDP编程、TCP编程、网络编程API使用、错误处理机制以及实际编程示例。套接字编程是网络应用开发的核心技能，掌握这些知识对于构建各种网络应用至关重要。

## 2. 套接字基础概念

### 2.1 套接字定义

套接字（Socket）是网络通信的端点，是应用程序与网络协议栈之间的接口。它提供了进程间通信的机制，使得不同主机上的进程能够通过网络进行数据交换。

**套接字的特点：**
- **通信端点**：标识网络中的特定进程
- **双向通信**：支持数据的发送和接收
- **协议无关**：支持多种网络协议
- **跨平台**：提供统一的编程接口

### 2.2 套接字类型

#### 2.2.1 按协议分类

**流套接字（SOCK_STREAM）：**
- 使用TCP协议
- 提供可靠的、面向连接的数据传输
- 数据按顺序到达，无重复
- 适合文件传输、Web服务等应用

**数据报套接字（SOCK_DGRAM）：**
- 使用UDP协议
- 提供无连接的数据传输
- 数据可能丢失、重复或乱序
- 适合实时通信、广播等应用

**原始套接字（SOCK_RAW）：**
- 直接访问底层协议
- 可以构造自定义协议头
- 需要管理员权限
- 适合网络工具开发

#### 2.2.2 按地址族分类

**IPv4套接字（AF_INET）：**
- 使用32位IP地址
- 最常用的套接字类型
- 支持TCP和UDP协议

**IPv6套接字（AF_INET6）：**
- 使用128位IP地址
- 支持IPv6网络
- 向后兼容IPv4

**本地套接字（AF_UNIX）：**
- 用于同一主机内的进程通信
- 使用文件系统路径作为地址
- 比网络套接字更高效

### 2.3 套接字地址结构

#### 2.3.1 通用套接字地址结构

```c
#include <sys/socket.h>

struct sockaddr {
    sa_family_t sa_family;    // 地址族
    char        sa_data[14];  // 地址数据
};
```

#### 2.3.2 IPv4套接字地址结构

```c
#include <netinet/in.h>

struct sockaddr_in {
    sa_family_t    sin_family;   // 地址族 (AF_INET)
    in_port_t      sin_port;     // 端口号 (网络字节序)
    struct in_addr sin_addr;     // IPv4地址
    char           sin_zero[8];  // 填充字段
};

struct in_addr {
    in_addr_t s_addr;  // IPv4地址 (网络字节序)
};
```

#### 2.3.3 IPv6套接字地址结构

```c
#include <netinet/in.h>

struct sockaddr_in6 {
    sa_family_t     sin6_family;   // 地址族 (AF_INET6)
    in_port_t       sin6_port;     // 端口号 (网络字节序)
    uint32_t        sin6_flowinfo; // 流信息
    struct in6_addr sin6_addr;     // IPv6地址
    uint32_t        sin6_scope_id; // 范围ID
};

struct in6_addr {
    unsigned char s6_addr[16];  // IPv6地址
};
```

### 2.4 字节序转换回顾

在套接字编程中，字节序转换是必须的：

```c
#include <arpa/inet.h>

// 16位整数转换
uint16_t htons(uint16_t hostshort);  // 主机 → 网络
uint16_t ntohs(uint16_t netshort);   // 网络 → 主机

// 32位整数转换
uint32_t htonl(uint32_t hostlong);   // 主机 → 网络
uint32_t ntohl(uint32_t netlong);    // 网络 → 主机

// IP地址转换
int inet_pton(int af, const char *src, void *dst);
const char *inet_ntop(int af, const void *src, 
                     char *dst, socklen_t size);
```

## 3. UDP协议编程

### 3.1 UDP协议特点

UDP（User Datagram Protocol）是无连接、不可靠的传输层协议，具有以下特点：

**优点：**
- **简单高效**：协议简单，开销小
- **无连接**：不需要建立连接
- **实时性好**：适合实时应用
- **支持广播/多播**：可以同时向多个主机发送数据

**缺点：**
- **不可靠**：不保证数据到达
- **无顺序保证**：数据可能乱序到达
- **无流量控制**：可能造成数据丢失

**适用场景：**
- 实时音视频传输
- 在线游戏
- DNS查询
- 网络发现和广播

### 3.2 UDP编程API

#### 3.2.1 创建套接字

```c
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
```

**参数说明：**
- `domain`：协议族（AF_INET, AF_INET6, AF_UNIX）
- `type`：套接字类型（SOCK_STREAM, SOCK_DGRAM, SOCK_RAW）
- `protocol`：具体协议（通常为0，让系统自动选择）

**返回值：**
- 成功：返回套接字文件描述符
- 失败：返回-1，设置errno

**示例：**
```c
int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
if (sockfd == -1) {
    perror("socket");
    exit(EXIT_FAILURE);
}
```

#### 3.2.2 绑定地址

```c
#include <sys/socket.h>

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

**参数说明：**
- `sockfd`：套接字文件描述符
- `addr`：要绑定的地址结构
- `addrlen`：地址结构长度

**示例：**
```c
struct sockaddr_in server_addr;
memset(&server_addr, 0, sizeof(server_addr));
server_addr.sin_family = AF_INET;
server_addr.sin_addr.s_addr = INADDR_ANY;  // 监听所有接口
server_addr.sin_port = htons(8080);        // 端口号

if (bind(sockfd, (struct sockaddr*)&server_addr, 
         sizeof(server_addr)) == -1) {
    perror("bind");
    close(sockfd);
    exit(EXIT_FAILURE);
}
```

#### 3.2.3 发送数据

```c
#include <sys/socket.h>

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
               const struct sockaddr *dest_addr, socklen_t addrlen);
```

**参数说明：**
- `sockfd`：套接字文件描述符
- `buf`：要发送的数据缓冲区
- `len`：数据长度
- `flags`：发送标志（通常为0）
- `dest_addr`：目标地址
- `addrlen`：目标地址长度

**示例：**
```c
const char *message = "Hello, UDP Server!";
struct sockaddr_in client_addr;
client_addr.sin_family = AF_INET;
inet_pton(AF_INET, "192.168.1.100", &client_addr.sin_addr);
client_addr.sin_port = htons(8080);

ssize_t bytes_sent = sendto(sockfd, message, strlen(message), 0,
                           (struct sockaddr*)&client_addr, 
                           sizeof(client_addr));
if (bytes_sent == -1) {
    perror("sendto");
}
```

#### 3.2.4 接收数据

```c
#include <sys/socket.h>

ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                 struct sockaddr *src_addr, socklen_t *addrlen);
```

**参数说明：**
- `sockfd`：套接字文件描述符
- `buf`：接收数据缓冲区
- `len`：缓冲区长度
- `flags`：接收标志（通常为0）
- `src_addr`：源地址（输出参数）
- `addrlen`：源地址长度（输入输出参数）

**示例：**
```c
char buffer[1024];
struct sockaddr_in client_addr;
socklen_t client_len = sizeof(client_addr);

ssize_t bytes_received = recvfrom(sockfd, buffer, sizeof(buffer) - 1, 0,
                                 (struct sockaddr*)&client_addr, &client_len);
if (bytes_received == -1) {
    perror("recvfrom");
} else {
    buffer[bytes_received] = '\0';
    printf("Received: %s\n", buffer);
}
```

#### 3.2.5 关闭套接字

```c
#include <unistd.h>

int close(int fd);
```

### 3.3 UDP编程示例

#### 3.3.1 UDP服务器示例

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE 1024
#define PORT 8080

int main() {
    int sockfd;
    struct sockaddr_in server_addr, client_addr;
    char buffer[BUFFER_SIZE];
    socklen_t client_len;
    ssize_t bytes_received;

    // 创建套接字
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 设置服务器地址
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    // 绑定地址
    if (bind(sockfd, (struct sockaddr*)&server_addr, 
             sizeof(server_addr)) == -1) {
        perror("bind");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    printf("UDP Server listening on port %d\n", PORT);

    // 接收和发送数据
    while (1) {
        client_len = sizeof(client_addr);
        bytes_received = recvfrom(sockfd, buffer, BUFFER_SIZE - 1, 0,
                                 (struct sockaddr*)&client_addr, &client_len);
        
        if (bytes_received == -1) {
            perror("recvfrom");
            continue;
        }

        buffer[bytes_received] = '\0';
        
        // 打印客户端信息
        char client_ip[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
        printf("Received from %s:%d: %s\n", 
               client_ip, ntohs(client_addr.sin_port), buffer);

        // 回显数据
        const char *response = "Echo: ";
        char reply[BUFFER_SIZE];
        snprintf(reply, sizeof(reply), "%s%s", response, buffer);
        
        sendto(sockfd, reply, strlen(reply), 0,
               (struct sockaddr*)&client_addr, client_len);
    }

    close(sockfd);
    return 0;
}
```

#### 3.3.2 UDP客户端示例

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE 1024
#define SERVER_PORT 8080
#define SERVER_IP "127.0.0.1"

int main() {
    int sockfd;
    struct sockaddr_in server_addr;
    char buffer[BUFFER_SIZE];
    ssize_t bytes_sent, bytes_received;

    // 创建套接字
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 设置服务器地址
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    inet_pton(AF_INET, SERVER_IP, &server_addr.sin_addr);

    // 发送数据
    const char *message = "Hello, UDP Server!";
    bytes_sent = sendto(sockfd, message, strlen(message), 0,
                       (struct sockaddr*)&server_addr, sizeof(server_addr));
    if (bytes_sent == -1) {
        perror("sendto");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    printf("Sent: %s\n", message);

    // 接收响应
    socklen_t server_len = sizeof(server_addr);
    bytes_received = recvfrom(sockfd, buffer, BUFFER_SIZE - 1, 0,
                             (struct sockaddr*)&server_addr, &server_len);
    if (bytes_received == -1) {
        perror("recvfrom");
    } else {
        buffer[bytes_received] = '\0';
        printf("Received: %s\n", buffer);
    }

    close(sockfd);
    return 0;
}
```

### 3.4 UDP编程注意事项

#### 3.4.1 数据包大小限制

**UDP数据包限制：**
- 理论最大：65535字节（IP头部限制）
- 实际最大：约1472字节（以太网MTU 1500 - IP头部20 - UDP头部8）
- 建议大小：512字节以下，避免分片

**处理大数据包：**
```c
// 检查数据包大小
if (len > 1472) {
    fprintf(stderr, "Warning: Large packet may be fragmented\n");
}

// 分片处理
#define MAX_UDP_PAYLOAD 1472
if (len > MAX_UDP_PAYLOAD) {
    // 实现应用层分片协议
    send_fragmented_data(sockfd, data, len, dest_addr);
}
```

#### 3.4.2 错误处理

**常见错误类型：**
- `EAGAIN/EWOULDBLOCK`：暂时无数据可读
- `ECONNREFUSED`：目标端口无服务
- `ENETUNREACH`：网络不可达
- `EHOSTUNREACH`：主机不可达

**错误处理示例：**
```c
ssize_t bytes_received = recvfrom(sockfd, buffer, sizeof(buffer), 0,
                                 (struct sockaddr*)&client_addr, &client_len);
if (bytes_received == -1) {
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
        // 暂时无数据，继续等待
        continue;
    } else if (errno == ECONNREFUSED) {
        fprintf(stderr, "Connection refused\n");
    } else {
        perror("recvfrom");
    }
    break;
}
```

#### 3.4.3 超时处理

**设置接收超时：**
```c
#include <sys/time.h>

struct timeval timeout;
timeout.tv_sec = 5;   // 5秒
timeout.tv_usec = 0;

if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, 
               &timeout, sizeof(timeout)) == -1) {
    perror("setsockopt");
}
```

## 4. TCP协议编程

### 4.1 TCP协议特点

TCP（Transmission Control Protocol）是面向连接、可靠的传输层协议，具有以下特点：

**优点：**
- **可靠传输**：保证数据完整性和顺序
- **流量控制**：防止发送方发送过快
- **拥塞控制**：避免网络拥塞
- **全双工通信**：支持双向数据传输

**缺点：**
- **连接开销**：需要建立和关闭连接
- **传输效率**：协议开销较大
- **实时性差**：不适合实时应用

**适用场景：**
- 文件传输
- Web服务
- 数据库连接
- 邮件传输

### 4.2 TCP连接管理

#### 4.2.1 三次握手（建立连接）

```
客户端                    服务器
    │                        │
    │ ──── SYN ────────────→ │
    │                        │
    │ ←── SYN+ACK ────────── │
    │                        │
    │ ──── ACK ────────────→ │
    │                        │
    │    连接建立完成        │
```

**状态转换：**
- 客户端：CLOSED → SYN_SENT → ESTABLISHED
- 服务器：CLOSED → LISTEN → SYN_RCVD → ESTABLISHED

#### 4.2.2 四次挥手（关闭连接）

```
客户端                    服务器
    │                        │
    │ ──── FIN ────────────→ │
    │                        │
    │ ←── ACK ────────────── │
    │                        │
    │ ←── FIN ────────────── │
    │                        │
    │ ──── ACK ────────────→ │
    │                        │
    │    连接关闭完成        │
```

**状态转换：**
- 主动关闭：ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED
- 被动关闭：ESTABLISHED → CLOSE_WAIT → LAST_ACK → CLOSED

### 4.3 TCP编程API

#### 4.3.1 服务器端API

**监听连接：**
```c
#include <sys/socket.h>

int listen(int sockfd, int backlog);
```

**参数说明：**
- `sockfd`：套接字文件描述符
- `backlog`：等待连接队列的最大长度
注意：listen() 将 socket 变为监听状态，并创建连接队列；backlog 控制的是“已完成三次握手、等待 accept 的连接”的最大数量。

**接受连接：**
```c
#include <sys/socket.h>

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

**参数说明：**
- `sockfd`：监听套接字
- `addr`：客户端地址（输出参数）
- `addrlen`：地址长度（输入输出参数）

**返回值：**
- 成功：返回新的连接套接字
- 失败：返回-1，设置errno

#### 4.3.2 客户端API

**发起连接：**
```c
#include <sys/socket.h>

int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

**参数说明：**
- `sockfd`：套接字文件描述符
- `addr`：服务器地址
- `addrlen`：地址长度

#### 4.3.3 数据传输API

**发送数据：**
```c
#include <sys/socket.h>

ssize_t send(int sockfd, const void *buf, size_t len, int flags);
返回值	说明
>0	实际发送的字节数（可能 < len）
=0	几乎不会出现
-1	发生错误
ssize_t write(int sockfd, const void *buf, size_t nbytes);
```

**接收数据：**
```c
#include <sys/socket.h>

ssize_t recv(int sockfd, void *buf, size_t len, int flags);
返回值	说明
>0	实际收到的数据字节数
=0	对端优雅关闭连接（close）
-1	发生错误（详见 errno）
ssize_t read(int sockfd, void *buf, size_t nbytes);
```

**send() vs write()：**
- `send()`：专门用于套接字，支持更多标志
- `write()`：通用文件操作，简单易用

### 4.4 TCP编程示例

#### 4.4.1 TCP服务器示例

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>

#define BUFFER_SIZE 1024
#define PORT 8080
#define MAX_CLIENTS 10

int server_sockfd;

void signal_handler(int sig) {
    printf("\nShutting down server...\n");
    close(server_sockfd);
    exit(0);
}

int main() {
    int client_sockfd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len;
    char buffer[BUFFER_SIZE];
    ssize_t bytes_received;

    // 设置信号处理
    signal(SIGINT, signal_handler);

    // 创建套接字
    server_sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 设置套接字选项（允许地址重用）
    int opt = 1;
    if (setsockopt(server_sockfd, SOL_SOCKET, SO_REUSEADDR, 
                   &opt, sizeof(opt)) == -1) {
        perror("setsockopt");
        close(server_sockfd);
        exit(EXIT_FAILURE);
    }

    // 设置服务器地址
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    // 绑定地址
    if (bind(server_sockfd, (struct sockaddr*)&server_addr, 
             sizeof(server_addr)) == -1) {
        perror("bind");
        close(server_sockfd);
        exit(EXIT_FAILURE);
    }

    // 开始监听
    if (listen(server_sockfd, MAX_CLIENTS) == -1) {
        perror("listen");
        close(server_sockfd);
        exit(EXIT_FAILURE);
    }

    printf("TCP Server listening on port %d\n", PORT);

    // 接受连接并处理
    while (1) {
        client_len = sizeof(client_addr);
        client_sockfd = accept(server_sockfd, 
                              (struct sockaddr*)&client_addr, &client_len);
        
        if (client_sockfd == -1) {
            perror("accept");
            continue;
        }

        // 打印客户端信息
        char client_ip[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
        printf("Client connected: %s:%d\n", 
               client_ip, ntohs(client_addr.sin_port));

        // 处理客户端请求
        while (1) {
            bytes_received = recv(client_sockfd, buffer, BUFFER_SIZE - 1, 0);
            if (bytes_received <= 0) {
                if (bytes_received == 0) {
                    printf("Client disconnected\n");
                } else {
                    perror("recv");
                }
                break;
            }

            buffer[bytes_received] = '\0';
            printf("Received: %s", buffer);

            // 回显数据
            const char *response = "Echo: ";
            char reply[BUFFER_SIZE];
            snprintf(reply, sizeof(reply), "%s%s", response, buffer);
            
            if (send(client_sockfd, reply, strlen(reply), 0) == -1) {
                perror("send");
                break;
            }
        }

        close(client_sockfd);
    }

    close(server_sockfd);
    return 0;
}
```

#### 4.4.2 TCP客户端示例

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE 1024
#define SERVER_PORT 8080
#define SERVER_IP "127.0.0.1"

int main() {
    int sockfd;
    struct sockaddr_in server_addr;
    char buffer[BUFFER_SIZE];
    ssize_t bytes_sent, bytes_received;

    // 创建套接字
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 设置服务器地址
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    inet_pton(AF_INET, SERVER_IP, &server_addr.sin_addr);

    // 连接到服务器
    if (connect(sockfd, (struct sockaddr*)&server_addr, 
                sizeof(server_addr)) == -1) {
        perror("connect");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    printf("Connected to server %s:%d\n", SERVER_IP, SERVER_PORT);

    // 发送和接收数据
    while (1) {
        printf("Enter message (or 'quit' to exit): ");
        if (fgets(buffer, BUFFER_SIZE, stdin) == NULL) {
            break;
        }

        // 检查退出命令
        if (strncmp(buffer, "quit", 4) == 0) {
            break;
        }

        // 发送数据
        bytes_sent = send(sockfd, buffer, strlen(buffer), 0);
        if (bytes_sent == -1) {
            perror("send");
            break;
        }

        // 接收响应
        bytes_received = recv(sockfd, buffer, BUFFER_SIZE - 1, 0);
        if (bytes_received <= 0) {
            if (bytes_received == 0) {
                printf("Server disconnected\n");
            } else {
                perror("recv");
            }
            break;
        }

        buffer[bytes_received] = '\0';
        printf("Server response: %s", buffer);
    }

    close(sockfd);
    return 0;
}
```

### 4.5 TCP编程注意事项

#### 4.5.1 连接管理

**TIME_WAIT状态：**
- 主动关闭连接的一方会进入TIME_WAIT状态
- 持续时间：2MSL（Maximum Segment Lifetime）
- 目的：确保最后的ACK到达，处理延迟的数据包

**处理TIME_WAIT：**
```c
// 设置SO_REUSEADDR选项
int opt = 1;
setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
```
int setsockopt(
    int sockfd,        // 套接字描述符
    int level,         // 选项所在协议层
    int optname,       // 选项名
    const void *optval,// 设置的值
    socklen_t optlen   // optval 的大小
);
参数：
- level —— 决定选项属于哪一层：
  - SOL_SOCKET通用 socket 层（所有协议通用）
  - IPPROTO_TCP TCP 专有选项
- optname
  - 端口复用 SO_REUSEADDR（服务器必加）
  - 端口共享 SO_REUSEPORT（多进程共享端口）
- optval 选项值，取决于上
返回值：
- 成功 → 0
- 失败 → -1（同时设置 errno）

作用详解：
允许当前套接字绑定到一个“处于 TIME_WAIT 状态”的端口上。
TCP 四次挥手后，主动关闭的一方会将端口维持 TIME_WAIT 状态（一般 1~4 分钟）。
启用 SO_REUSEADDR 后，可以立即重新绑定端口，不需要等待，否则会报端口占用的错。

注意：
- 服务器必须设置，不加你的服务要等几分钟才能重启。
- 必须在 bind 前设置

#### 4.5.2 数据边界问题

**TCP是字节流协议：**
- 不保持消息边界
- 可能一次接收多个消息
- 可能一次发送多个消息

**解决方案：**
```c
// 1. 固定长度消息
#define MESSAGE_SIZE 100
char message[MESSAGE_SIZE];

// 2. 长度前缀
uint32_t length;
recv(sockfd, &length, sizeof(length), 0);
length = ntohl(length);
char *data = malloc(length);
recv(sockfd, data, length, 0);

// 3. 分隔符
char buffer[BUFFER_SIZE];
char *end = strstr(buffer, "\n");
if (end) {
    *end = '\0';
    process_message(buffer);
}
```

#### 4.5.3 阻塞与非阻塞I/O

**阻塞I/O：**
- 默认模式
- 操作会等待直到完成
- 简单易用，但效率较低

**非阻塞I/O：**
```c
// 设置非阻塞模式
int flags = fcntl(sockfd, F_GETFL, 0);
fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);

// 检查操作结果
ssize_t bytes = recv(sockfd, buffer, sizeof(buffer), 0);
if (bytes == -1) {
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
        // 暂时无数据
        continue;
    } else {
        perror("recv");
        break;
    }
}
```
**补充**
`int fcntl(int fd, int cmd, ... /* arg */ );`
参数：
  - fd：要控制的文件描述符（文件 / socket / 管道 / epoll fd 都可以）
  - cmd：要执行的操作命令。常用：F_GETFL / F_SETFL —— 获取/设置文件状态
  - arg：可选参数，取决于 cmd. O_NONBLOCK（非阻塞）O_APPEND（追加）
返回值：
  - 成功：非负数
  - 失败：-1

## 5. 网络编程最佳实践

### 5.1 错误处理

**标准错误处理模式：**
```c
int result = some_system_call();
if (result == -1) {
    perror("system_call_name");
    // 清理资源
    cleanup();
    exit(EXIT_FAILURE);
}
```

**errno值检查：**
```c
#include <errno.h>

if (result == -1) {
    switch (errno) {
        case EAGAIN:
        case EWOULDBLOCK:
            // 暂时无数据，继续等待
            break;
        case ECONNREFUSED:
            fprintf(stderr, "Connection refused\n");
            break;
        case ENETUNREACH:
            fprintf(stderr, "Network unreachable\n");
            break;
        default:
            perror("system_call");
            break;
    }
}
```

### 5.2 性能优化

#### 5.2.1 缓冲区管理

**缓冲区大小选择：**
```c
// 根据应用需求选择缓冲区大小
#define SMALL_BUFFER  512   // 小消息
#define LARGE_BUFFER  8192  // 大文件传输
#define MAX_BUFFER    65536 // 最大缓冲区

// 动态调整缓冲区
size_t buffer_size = 1024;
char *buffer = malloc(buffer_size);
if (bytes_received == buffer_size) {
    // 缓冲区可能不够，扩大
    buffer_size *= 2;
    buffer = realloc(buffer, buffer_size);
}
```

#### 5.2.2 批量操作

**批量发送：**
```c
// 收集多个消息后批量发送
struct message_queue {
    char messages[MAX_MESSAGES][MESSAGE_SIZE];
    int count;
};

void flush_messages(int sockfd, struct message_queue *queue) {
    for (int i = 0; i < queue->count; i++) {
        send(sockfd, queue->messages[i], strlen(queue->messages[i]), 0);
    }
    queue->count = 0;
}
```

### 5.3 安全考虑

#### 5.3.1 输入验证

**数据长度检查：**
```c
ssize_t safe_recv(int sockfd, char *buffer, size_t max_len) {
    ssize_t bytes_received = recv(sockfd, buffer, max_len - 1, 0);
    if (bytes_received > 0) {
        buffer[bytes_received] = '\0';
        // 检查是否有缓冲区溢出
        if (strlen(buffer) != (size_t)bytes_received) {
            fprintf(stderr, "Warning: Null byte in received data\n");
        }
    }
    return bytes_received;
}
```

#### 5.3.2 权限控制

**端口权限检查：**
```c
// 检查是否需要root权限
if (port < 1024) {
    if (getuid() != 0) {
        fprintf(stderr, "Root privileges required for port %d\n", port);
        exit(EXIT_FAILURE);
    }
}
```

## 6. 调试和测试

### 6.1 调试技巧

#### 6.1.1 网络调试工具

**tcpdump使用：**
常用参数
- -i <网卡>：指定网卡，如 eth0、lo（回环），any 表示所有网卡。
- -w <文件>：将原始数据写入文件，供Wireshark等工具分析。
- -X 或 -A：以十六进制/ASCII格式显示包内容
注意：tcpdump不会导致丢包，其先于recvfrom获取数据的副本
```bash
# 抓取所有TCP包
tcpdump -i any tcp

# 抓取特定端口的包
tcpdump -i any port 8080

# 抓取特定主机的包
tcpdump -i any host 192.168.1.100

# 保存到文件
tcpdump -i any -w capture.pcap

# 抓取网卡ens33下，端口为13145的udp包，并以ASCII码显示
tcpdump -i ens33 -A udp  port 13145
```

**netstat使用：**
```bash
# 查看所有监听端口 + 进程
netstat -tunlp

# 查看监听端口
netstat -ln

# 查端口占用
netstat -tunlp | grep :8080

# 查 TCP 连接
netstat -ant

# 查看某个应用可能占用了哪些端口
netstat -tunlp > before.txt
启动你要监控的应用
netstat -tunlp > after.txt
diff before.txt after.txt
```

#### 6.1.2 程序调试

**添加调试信息：**
```c
#ifdef DEBUG
#define DEBUG_PRINT(fmt, ...) \
    fprintf(stderr, "[DEBUG] " fmt "\n", ##__VA_ARGS__)
#else
#define DEBUG_PRINT(fmt, ...)
#endif

// 使用示例
DEBUG_PRINT("Received %zd bytes from %s:%d", 
           bytes_received, client_ip, client_port);
```

### 6.2 单元测试

#### 6.2.1 测试框架

**使用Google Test：**
```c
#include <gtest/gtest.h>

TEST(SocketTest, CreateSocket) {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    EXPECT_NE(sockfd, -1);
    close(sockfd);
}

TEST(SocketTest, BindAddress) {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    ASSERT_NE(sockfd, -1);
    
    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(0); // 让系统选择端口
    
    EXPECT_EQ(bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)), 0);
    close(sockfd);
}
```

#### 6.2.2 集成测试

**客户端-服务器测试：**
```c
void test_client_server_communication() {
    // 启动服务器
    pid_t server_pid = fork();
    if (server_pid == 0) {
        // 子进程运行服务器
        run_server();
        exit(0);
    }
    
    // 等待服务器启动
    sleep(1);
    
    // 运行客户端测试
    int result = run_client_test();
    
    // 清理
    kill(server_pid, SIGTERM);
    waitpid(server_pid, NULL, 0);
    
    ASSERT_EQ(result, 0);
}
```

## 7. 常见问题和解决方案

### 7.1 连接问题

#### 7.1.1 连接被拒绝

**原因：**
- 目标端口无服务监听
- 防火墙阻止连接
- 服务未启动

**解决方案：**
```c
if (connect(sockfd, (struct sockaddr*)&server_addr, 
            sizeof(server_addr)) == -1) {
    if (errno == ECONNREFUSED) {
        fprintf(stderr, "Connection refused. Check if server is running.\n");
    } else if (errno == ETIMEDOUT) {
        fprintf(stderr, "Connection timeout. Check network connectivity.\n");
    } else {
        perror("connect");
    }
}
```

#### 7.1.2 地址已在使用

**原因：**
- 端口被其他程序占用
- 程序异常退出，端口未释放

**解决方案：**
```c
// 设置SO_REUSEADDR选项
int opt = 1;
if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, 
               &opt, sizeof(opt)) == -1) {
    perror("setsockopt");
}

// 检查端口是否被占用
int check_port_available(int port) {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) return 0;
    
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(port);
    
    int result = bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
    close(sockfd);
    return result == 0;
}
```

### 7.2 数据传输问题

#### 7.2.1 数据丢失

**UDP数据丢失：**
```c
// 实现简单的重传机制
#define MAX_RETRIES 3
#define TIMEOUT_SEC 1

int reliable_send(int sockfd, const void *data, size_t len, 
                  const struct sockaddr *dest_addr, socklen_t addrlen) {
    for (int retry = 0; retry < MAX_RETRIES; retry++) {
        ssize_t sent = sendto(sockfd, data, len, 0, dest_addr, addrlen);
        if (sent == len) {
            return 0; // 发送成功
        }
        
        if (retry < MAX_RETRIES - 1) {
            sleep(TIMEOUT_SEC);
        }
    }
    return -1; // 发送失败
}
```

#### 7.2.2 数据乱序

**TCP数据乱序处理：**
```c
// 使用序列号处理乱序数据
struct message {
    uint32_t seq;
    uint32_t len;
    char data[0];
};

void handle_message(const struct message *msg) {
    static uint32_t expected_seq = 0;
    
    if (msg->seq == expected_seq) {
        // 按序到达，处理消息
        process_data(msg->data, msg->len);
        expected_seq++;
    } else if (msg->seq > expected_seq) {
        // 乱序到达，缓存消息
        cache_message(msg);
    }
    // 丢弃重复或过期的消息
}
```

## 8. 总结

套接字编程是网络应用开发的核心技能，本章详细介绍了：

1. **套接字基础**：概念、类型、地址结构
2. **UDP编程**：无连接、不可靠的数据传输
3. **TCP编程**：面向连接、可靠的字节流传输
4. **最佳实践**：错误处理、性能优化、安全考虑
5. **调试测试**：工具使用、单元测试、集成测试
6. **问题解决**：常见问题的诊断和解决方案

掌握这些知识后，您就能够开发各种网络应用程序，为学习更高级的I/O模型和服务器架构奠定基础。

在实际编程中，要特别注意：
- 字节序转换
- 错误处理
- 资源管理
- 数据边界问题
- 性能优化

---

**文档版本**：v1.0  
**创建时间**：2025年09月30日 16:43:10 CST  
**最后更新**：2025年09月30日 16:43:10 CST  
**维护者**：Gamma
