# æœåŠ¡å™¨æ¶æ„è®¾è®¡

## 1. æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†Linuxç½‘ç»œç¼–ç¨‹ä¸­çš„æœåŠ¡å™¨æ¶æ„è®¾è®¡ï¼ŒåŒ…æ‹¬åŸºç¡€æœåŠ¡å™¨æ¨¡å‹ã€é«˜çº§æœåŠ¡å™¨æ¨¡å‹ã€äº‹ä»¶é©±åŠ¨æ¶æ„ã€è´Ÿè½½å‡è¡¡ä¸ä»£ç†ç­‰æ ¸å¿ƒå†…å®¹ã€‚æœåŠ¡å™¨æ¶æ„è®¾è®¡æ˜¯æ„å»ºé«˜æ€§èƒ½ã€é«˜å¯ç”¨ç½‘ç»œåº”ç”¨çš„å…³é”®æŠ€æœ¯ï¼ŒæŒæ¡è¿™äº›çŸ¥è¯†å¯¹äºå¼€å‘ä¼ä¸šçº§ç½‘ç»œæœåŠ¡è‡³å…³é‡è¦ã€‚

æœ¬æ–‡æ¡£å°†ä»ç®€å•çš„ä¸²è¡ŒæœåŠ¡å™¨å¼€å§‹ï¼Œé€æ­¥æ·±å…¥åˆ°å¤šè¿›ç¨‹ã€å¤šçº¿ç¨‹ã€äº‹ä»¶é©±åŠ¨ç­‰å¤æ‚æ¶æ„ï¼Œå¸®åŠ©è¯»è€…ç†è§£ä¸åŒæ¶æ„çš„ä¼˜ç¼ºç‚¹ã€é€‚ç”¨åœºæ™¯ä»¥åŠå®ç°æ–¹æ³•ã€‚é€šè¿‡å­¦ä¹ æœ¬æ–‡æ¡£ï¼Œè¯»è€…å°†èƒ½å¤Ÿï¼š

- ç†è§£å„ç§æœåŠ¡å™¨æ¶æ„æ¨¡å‹çš„ç‰¹ç‚¹å’Œé€‚ç”¨åœºæ™¯
- æŒæ¡å¤šè¿›ç¨‹å’Œå¤šçº¿ç¨‹æœåŠ¡å™¨çš„å®ç°æ–¹æ³•
- ç†è§£Reactorå’ŒProactoräº‹ä»¶é©±åŠ¨æ¨¡å¼
- å­¦ä¼šè®¾è®¡é«˜æ€§èƒ½çš„æœåŠ¡å™¨æ¶æ„
- äº†è§£è´Ÿè½½å‡è¡¡å’Œåå‘ä»£ç†çš„å®ç°åŸç†

## 2. æœåŠ¡å™¨æ¶æ„åŸºç¡€

### 2.1 æœåŠ¡å™¨æ¶æ„åˆ†ç±»

æœåŠ¡å™¨æ¶æ„å¯ä»¥æ ¹æ®å¤„ç†è¿æ¥çš„æ–¹å¼è¿›è¡Œåˆ†ç±»ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æœåŠ¡å™¨æ¶æ„åˆ†ç±»ä½“ç³»                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ“‹ åŸºç¡€æ¶æ„æ¨¡å‹                                              â”‚
â”‚  â”œâ”€â”€ ä¸²è¡Œ/è¿­ä»£æœåŠ¡å™¨ (Serial/Iterative Server)              â”‚
â”‚  â”œâ”€â”€ è¿›ç¨‹æ¯è¿æ¥æ¨¡å‹ (Process-per-Connection)                â”‚
â”‚  â””â”€â”€ çº¿ç¨‹æ¯è¿æ¥æ¨¡å‹ (Thread-per-Connection)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  âš¡ é«˜çº§æ¶æ„æ¨¡å‹                                              â”‚
â”‚  â”œâ”€â”€ çº¿ç¨‹æ± æ¨¡å‹ (Thread Pool)                               â”‚
â”‚  â”œâ”€â”€ è¿›ç¨‹æ± æ¨¡å‹ (Process Pool / Prefork)                   â”‚
â”‚  â”œâ”€â”€ äº‹ä»¶é©±åŠ¨æ¨¡å‹ (Event-Driven)                            â”‚
â”‚  â”‚   â”œâ”€â”€ Reactoræ¨¡å¼                                        â”‚
â”‚  â”‚   â””â”€â”€ Proactoræ¨¡å¼                                       â”‚
â”‚  â””â”€â”€ æ··åˆæ¶æ„æ¨¡å‹ (Hybrid Architecture)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ¢ åˆ†å¸ƒå¼æ¶æ„                                               â”‚
â”‚  â”œâ”€â”€ è´Ÿè½½å‡è¡¡ (Load Balancing)                              â”‚
â”‚  â”œâ”€â”€ åå‘ä»£ç† (Reverse Proxy)                               â”‚
â”‚  â””â”€â”€ æœåŠ¡å‘ç° (Service Discovery)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ¶æ„é€‰æ‹©å› ç´ 

åœ¨é€‰æ‹©æœåŠ¡å™¨æ¶æ„æ—¶ï¼Œéœ€è¦è€ƒè™‘ä»¥ä¸‹å› ç´ ï¼š

| å› ç´  | è¯´æ˜ | å½±å“ |
|------|------|------|
| **å¹¶å‘è¿æ¥æ•°** | åŒæ—¶å¤„ç†çš„è¿æ¥æ•°é‡ | å†³å®šæ˜¯å¦éœ€è¦å¤šè¿›ç¨‹/å¤šçº¿ç¨‹ |
| **è¯·æ±‚å¤„ç†æ—¶é—´** | å•ä¸ªè¯·æ±‚çš„å¤„ç†è€—æ—¶ | å½±å“æ˜¯å¦éœ€è¦å¼‚æ­¥å¤„ç† |
| **I/Oç±»å‹** | I/Oå¯†é›†å‹ vs CPUå¯†é›†å‹ | å†³å®šä½¿ç”¨äº‹ä»¶é©±åŠ¨è¿˜æ˜¯çº¿ç¨‹æ±  |
| **èµ„æºé™åˆ¶** | å†…å­˜ã€CPUã€æ–‡ä»¶æè¿°ç¬¦é™åˆ¶ | å½±å“è¿›ç¨‹/çº¿ç¨‹æ•°é‡ |
| **å¯æ‰©å±•æ€§** | æ°´å¹³æ‰©å±• vs å‚ç›´æ‰©å±• | å½±å“æ¶æ„è®¾è®¡ |
| **å¼€å‘å¤æ‚åº¦** | ä»£ç å¤æ‚åº¦å’Œç»´æŠ¤æˆæœ¬ | å½±å“æ¶æ„é€‰æ‹© |

### 2.3 æ€§èƒ½æŒ‡æ ‡

è¯„ä¼°æœåŠ¡å™¨æ¶æ„æ€§èƒ½çš„ä¸»è¦æŒ‡æ ‡ï¼š

**ååé‡ï¼ˆThroughputï¼‰ï¼š**
- å•ä½æ—¶é—´å†…å¤„ç†çš„è¯·æ±‚æ•°ï¼ˆQPS - Queries Per Secondï¼‰
- å•ä½æ—¶é—´å†…ä¼ è¾“çš„æ•°æ®é‡ï¼ˆBPS - Bytes Per Secondï¼‰

**å»¶è¿Ÿï¼ˆLatencyï¼‰ï¼š**
- è¯·æ±‚å¤„ç†æ—¶é—´ï¼ˆP99å»¶è¿Ÿã€å¹³å‡å»¶è¿Ÿï¼‰
- è¿æ¥å»ºç«‹æ—¶é—´

**å¹¶å‘èƒ½åŠ›ï¼ˆConcurrencyï¼‰ï¼š**
- æœ€å¤§å¹¶å‘è¿æ¥æ•°
- èµ„æºåˆ©ç”¨ç‡ï¼ˆCPUã€å†…å­˜ã€ç½‘ç»œï¼‰

**å¯æ‰©å±•æ€§ï¼ˆScalabilityï¼‰ï¼š**
- æ°´å¹³æ‰©å±•èƒ½åŠ›
- å‚ç›´æ‰©å±•èƒ½åŠ›

## 3. åŸºç¡€æœåŠ¡å™¨æ¨¡å‹

### 3.1 ä¸²è¡Œ/è¿­ä»£æœåŠ¡å™¨

ä¸²è¡ŒæœåŠ¡å™¨æ˜¯æœ€ç®€å•çš„æœåŠ¡å™¨æ¨¡å‹ï¼Œæ¯æ¬¡åªå¤„ç†ä¸€ä¸ªå®¢æˆ·ç«¯è¿æ¥ï¼Œå¤„ç†å®Œå½“å‰è¿æ¥åæ‰èƒ½æ¥å—ä¸‹ä¸€ä¸ªè¿æ¥ã€‚

#### 3.1.1 ä¸²è¡ŒæœåŠ¡å™¨ç‰¹ç‚¹

**ä¼˜ç‚¹ï¼š**
- å®ç°ç®€å•ï¼Œæ˜“äºç†è§£
- ä¸éœ€è¦è€ƒè™‘å¹¶å‘é—®é¢˜
- èµ„æºå ç”¨å°‘
- é€‚åˆç®€å•çš„ç½‘ç»œåº”ç”¨

**ç¼ºç‚¹ï¼š**
- æ€§èƒ½æå·®ï¼Œæ— æ³•å¹¶å‘å¤„ç†
- ä¸€ä¸ªå®¢æˆ·ç«¯é˜»å¡ä¼šå½±å“æ‰€æœ‰åç»­å®¢æˆ·ç«¯
- ä¸é€‚åˆç”Ÿäº§ç¯å¢ƒ

**é€‚ç”¨åœºæ™¯ï¼š**
- å­¦ä¹ ç½‘ç»œç¼–ç¨‹çš„å…¥é—¨ç¤ºä¾‹
- ç®€å•çš„å·¥å…·ç¨‹åº
- ä½å¹¶å‘çš„å†…éƒ¨æœåŠ¡

#### 3.1.2 ä¸²è¡ŒæœåŠ¡å™¨å®ç°

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

void handle_client(int client_fd) {
    char buffer[BUFFER_SIZE];
    ssize_t bytes_received;
    
    printf("Handling client connection\n");
    
    while (1) {
        // æ¥æ”¶æ•°æ®
        bytes_received = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
        if (bytes_received <= 0) {
            break;
        }
        
        buffer[bytes_received] = '\0';
        printf("Received: %s", buffer);
        
        // å¤„ç†è¯·æ±‚ï¼ˆæ¨¡æ‹Ÿå¤„ç†æ—¶é—´ï¼‰
        // è¿™é‡Œå¯ä»¥æ·»åŠ ä¸šåŠ¡é€»è¾‘å¤„ç†
        
        // å‘é€å“åº”
        send(client_fd, buffer, bytes_received, 0);
    }
    
    close(client_fd);
    printf("Client disconnected\n");
}

int main() {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len;
    
    // åˆ›å»ºå¥—æ¥å­—
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // è®¾ç½®åœ°å€é‡ç”¨
    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // é…ç½®æœåŠ¡å™¨åœ°å€
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    // ç»‘å®šåœ°å€
    if (bind(server_fd, (struct sockaddr*)&server_addr, 
             sizeof(server_addr)) == -1) {
        perror("bind");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    // å¼€å§‹ç›‘å¬
    if (listen(server_fd, 5) == -1) {
        perror("listen");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    printf("Serial Server listening on port %d\n", PORT);
    printf("Warning: This server can only handle one client at a time!\n");
    
    // ä¸²è¡Œå¤„ç†è¿æ¥
    while (1) {
        client_len = sizeof(client_addr);
        client_fd = accept(server_fd, (struct sockaddr*)&client_addr, 
                          &client_len);
        if (client_fd == -1) {
            perror("accept");
            continue;
        }
        
        printf("Client connected from %s:%d\n",
               inet_ntoa(client_addr.sin_addr),
               ntohs(client_addr.sin_port));
        
        // å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚ï¼ˆé˜»å¡ï¼‰
        handle_client(client_fd);
        
        // åªæœ‰å¤„ç†å®Œå½“å‰å®¢æˆ·ç«¯ï¼Œæ‰èƒ½æ¥å—ä¸‹ä¸€ä¸ªè¿æ¥
    }
    
    close(server_fd);
    return 0;
}
```

#### 3.1.3 ä¸²è¡ŒæœåŠ¡å™¨æ€§èƒ½åˆ†æ

| æŒ‡æ ‡ | å€¼ | è¯´æ˜ |
|------|-----|------|
| **å¹¶å‘è¿æ¥æ•°** | 1 | åŒæ—¶åªèƒ½å¤„ç†ä¸€ä¸ªè¿æ¥ |
| **ååé‡** | ä½ | å—é™äºå•çº¿ç¨‹å¤„ç† |
| **å»¶è¿Ÿ** | é«˜ | åç»­å®¢æˆ·ç«¯éœ€è¦ç­‰å¾… |
| **èµ„æºå ç”¨** | ä½ | å•è¿›ç¨‹å•çº¿ç¨‹ |
| **é€‚ç”¨åœºæ™¯** | å­¦ä¹ /æ¼”ç¤º | ä¸é€‚åˆç”Ÿäº§ç¯å¢ƒ |

### 3.2 è¿›ç¨‹æ¯è¿æ¥æ¨¡å‹

è¿›ç¨‹æ¯è¿æ¥æ¨¡å‹ï¼ˆProcess-per-Connectionï¼‰ä¸ºæ¯ä¸ªå®¢æˆ·ç«¯è¿æ¥åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„å­è¿›ç¨‹æ¥å¤„ç†è¯·æ±‚ã€‚

#### 3.2.1 è¿›ç¨‹æ¯è¿æ¥æ¨¡å‹ç‰¹ç‚¹

**ä¼˜ç‚¹ï¼š**
- è¿›ç¨‹é—´éš”ç¦»ï¼Œä¸€ä¸ªè¿›ç¨‹å´©æºƒä¸å½±å“å…¶ä»–è¿›ç¨‹
- ç¼–ç¨‹ç›¸å¯¹ç®€å•ï¼Œä¸éœ€è¦è€ƒè™‘çº¿ç¨‹åŒæ­¥
- å¯ä»¥åˆ©ç”¨å¤šæ ¸CPU
- é€‚åˆCPUå¯†é›†å‹ä»»åŠ¡

**ç¼ºç‚¹ï¼š**
- è¿›ç¨‹åˆ›å»ºå’Œé”€æ¯å¼€é”€å¤§
- å†…å­˜å ç”¨é«˜ï¼ˆæ¯ä¸ªè¿›ç¨‹ç‹¬ç«‹åœ°å€ç©ºé—´ï¼‰
- è¿›ç¨‹é—´é€šä¿¡å¤æ‚
- ä¸é€‚åˆé«˜å¹¶å‘åœºæ™¯

**é€‚ç”¨åœºæ™¯ï¼š**
- ä¸­ç­‰å¹¶å‘ï¼ˆ< 1000è¿æ¥ï¼‰
- CPUå¯†é›†å‹ä»»åŠ¡
- éœ€è¦è¿›ç¨‹éš”ç¦»çš„åœºæ™¯

#### 3.2.2 è¿›ç¨‹æ¯è¿æ¥æ¨¡å‹å®ç°

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>

#define PORT 8080
#define BUFFER_SIZE 1024

// ä¿¡å·å¤„ç†ï¼šå›æ”¶åƒµå°¸è¿›ç¨‹
void sigchld_handler(int sig) {
    while (waitpid(-1, NULL, WNOHANG) > 0);
}

void handle_client(int client_fd) {
    char buffer[BUFFER_SIZE];
    ssize_t bytes_received;
    
    printf("[PID %d] Handling client connection\n", getpid());
    
    while (1) {
        bytes_received = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
        if (bytes_received <= 0) {
            break;
        }
        
        buffer[bytes_received] = '\0';
        printf("[PID %d] Received: %s", getpid(), buffer);
        
        // å¤„ç†è¯·æ±‚
        // è¿™é‡Œå¯ä»¥æ·»åŠ ä¸šåŠ¡é€»è¾‘
        
        // å‘é€å“åº”
        send(client_fd, buffer, bytes_received, 0);
    }
    
    close(client_fd);
    printf("[PID %d] Client disconnected, process exiting\n", getpid());
    exit(0);
}

int main() {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len;
    pid_t child_pid;
    
    // æ³¨å†Œä¿¡å·å¤„ç†å‡½æ•°
    signal(SIGCHLD, sigchld_handler);
    
    // åˆ›å»ºå¥—æ¥å­—
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // è®¾ç½®åœ°å€é‡ç”¨
    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // é…ç½®æœåŠ¡å™¨åœ°å€
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    // ç»‘å®šåœ°å€
    if (bind(server_fd, (struct sockaddr*)&server_addr, 
             sizeof(server_addr)) == -1) {
        perror("bind");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    // å¼€å§‹ç›‘å¬
    if (listen(server_fd, 5) == -1) {
        perror("listen");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    printf("Process-per-Connection Server listening on port %d\n", PORT);
    printf("Main process PID: %d\n", getpid());
    
    while (1) {
        client_len = sizeof(client_addr);
        client_fd = accept(server_fd, (struct sockaddr*)&client_addr, 
                          &client_len);
        if (client_fd == -1) {
            perror("accept");
            continue;
        }
        
        printf("Client connected from %s:%d\n",
               inet_ntoa(client_addr.sin_addr),
               ntohs(client_addr.sin_port));
        
        // åˆ›å»ºå­è¿›ç¨‹å¤„ç†å®¢æˆ·ç«¯
        child_pid = fork();
        if (child_pid == -1) {
            perror("fork");
            close(client_fd);
            continue;
        }
        
        if (child_pid == 0) {
            // å­è¿›ç¨‹ï¼šå…³é—­ç›‘å¬å¥—æ¥å­—ï¼Œå¤„ç†å®¢æˆ·ç«¯
            close(server_fd);
            handle_client(client_fd);
            // handle_clientè¿”å›åä¼šexit
        } else {
            // çˆ¶è¿›ç¨‹ï¼šå…³é—­å®¢æˆ·ç«¯å¥—æ¥å­—ï¼Œç»§ç»­ç›‘å¬
            close(client_fd);
            printf("Created child process %d for client\n", child_pid);
        }
    }
    
    close(server_fd);
    return 0;
}
```

#### 3.2.3 è¿›ç¨‹æ¯è¿æ¥æ¨¡å‹ä¼˜åŒ–

**é¢„å…ˆforkæ¨¡å‹ï¼ˆPreforkï¼‰ï¼š**
é¢„å…ˆåˆ›å»ºä¸€å®šæ•°é‡çš„å­è¿›ç¨‹ï¼Œé¿å…é¢‘ç¹forkçš„å¼€é”€ï¼š

```c
#define PREFORK_COUNT 10

void prefork_workers(int server_fd) {
    pid_t pid;
    int i;
    
    for (i = 0; i < PREFORK_COUNT; i++) {
        pid = fork();
        if (pid == 0) {
            // å­è¿›ç¨‹ï¼šå¤„ç†è¿æ¥
            worker_process(server_fd);
            exit(0);
        } else if (pid < 0) {
            perror("fork");
            exit(EXIT_FAILURE);
        }
        printf("Created worker process %d\n", pid);
    }
}

void worker_process(int server_fd) {
    int client_fd;
    struct sockaddr_in client_addr;
    socklen_t client_len;
    
    while (1) {
        client_len = sizeof(client_addr);
        client_fd = accept(server_fd, (struct sockaddr*)&client_addr, 
                          &client_len);
        if (client_fd == -1) {
            perror("accept");
            continue;
        }
        
        printf("[Worker %d] Handling client\n", getpid());
        handle_client(client_fd);
        close(client_fd);
    }
}
```

#### 3.2.4 è¿›ç¨‹æ¯è¿æ¥æ¨¡å‹æ€§èƒ½åˆ†æ

| æŒ‡æ ‡ | å€¼ | è¯´æ˜ |
|------|-----|------|
| **å¹¶å‘è¿æ¥æ•°** | ä¸­ç­‰ï¼ˆ< 1000ï¼‰ | å—é™äºè¿›ç¨‹æ•°é‡ |
| **ååé‡** | ä¸­ç­‰ | è¿›ç¨‹åˆ‡æ¢å¼€é”€ |
| **å»¶è¿Ÿ** | ä¸­ç­‰ | è¿›ç¨‹åˆ›å»ºå¼€é”€ |
| **èµ„æºå ç”¨** | é«˜ | æ¯ä¸ªè¿›ç¨‹ç‹¬ç«‹å†…å­˜ç©ºé—´ |
| **é€‚ç”¨åœºæ™¯** | ä¸­ç­‰å¹¶å‘ã€CPUå¯†é›†å‹ | Apache preforkæ¨¡å¼ |

### 3.3 çº¿ç¨‹æ¯è¿æ¥æ¨¡å‹

çº¿ç¨‹æ¯è¿æ¥æ¨¡å‹ï¼ˆThread-per-Connectionï¼‰ä¸ºæ¯ä¸ªå®¢æˆ·ç«¯è¿æ¥åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„çº¿ç¨‹æ¥å¤„ç†è¯·æ±‚ã€‚

#### 3.3.1 çº¿ç¨‹æ¯è¿æ¥æ¨¡å‹ç‰¹ç‚¹

**ä¼˜ç‚¹ï¼š**
- çº¿ç¨‹åˆ›å»ºå’Œé”€æ¯å¼€é”€æ¯”è¿›ç¨‹å°
- çº¿ç¨‹é—´å…±äº«å†…å­˜ç©ºé—´ï¼Œé€šä¿¡æ–¹ä¾¿
- å¯ä»¥å……åˆ†åˆ©ç”¨å¤šæ ¸CPU
- é€‚åˆI/Oå¯†é›†å‹ä»»åŠ¡

**ç¼ºç‚¹ï¼š**
- çº¿ç¨‹åˆ›å»ºä»æœ‰å¼€é”€
- éœ€è¦å¤„ç†çº¿ç¨‹åŒæ­¥é—®é¢˜
- çº¿ç¨‹æ•°é‡å—é™äºç³»ç»Ÿèµ„æº
- çº¿ç¨‹åˆ‡æ¢å¼€é”€

**é€‚ç”¨åœºæ™¯ï¼š**
- ä¸­ç­‰å¹¶å‘ï¼ˆ< 5000è¿æ¥ï¼‰
- I/Oå¯†é›†å‹ä»»åŠ¡
- éœ€è¦å…±äº«æ•°æ®çš„åœºæ™¯

#### 3.3.2 çº¿ç¨‹æ¯è¿æ¥æ¨¡å‹å®ç°

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

// å®¢æˆ·ç«¯ä¿¡æ¯ç»“æ„
typedef struct {
    int client_fd;
    struct sockaddr_in client_addr;
} client_info_t;

void* handle_client(void* arg) {
    client_info_t* info = (client_info_t*)arg;
    int client_fd = info->client_fd;
    char buffer[BUFFER_SIZE];
    ssize_t bytes_received;
    
    printf("[Thread %lu] Handling client from %s:%d\n",
           pthread_self(),
           inet_ntoa(info->client_addr.sin_addr),
           ntohs(info->client_addr.sin_port));
    
    while (1) {
        bytes_received = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
        if (bytes_received <= 0) {
            break;
        }
        
        buffer[bytes_received] = '\0';
        printf("[Thread %lu] Received: %s", pthread_self(), buffer);
        
        // å¤„ç†è¯·æ±‚
        // è¿™é‡Œå¯ä»¥æ·»åŠ ä¸šåŠ¡é€»è¾‘
        
        // å‘é€å“åº”
        send(client_fd, buffer, bytes_received, 0);
    }
    
    close(client_fd);
    printf("[Thread %lu] Client disconnected, thread exiting\n", pthread_self());
    
    free(info);
    return NULL;
}

int main() {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len;
    pthread_t thread_id;
    client_info_t* client_info;
    
    // åˆ›å»ºå¥—æ¥å­—
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // è®¾ç½®åœ°å€é‡ç”¨
    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // é…ç½®æœåŠ¡å™¨åœ°å€
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    // ç»‘å®šåœ°å€
    if (bind(server_fd, (struct sockaddr*)&server_addr, 
             sizeof(server_addr)) == -1) {
        perror("bind");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    // å¼€å§‹ç›‘å¬
    if (listen(server_fd, 5) == -1) {
        perror("listen");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    printf("Thread-per-Connection Server listening on port %d\n", PORT);
    
    while (1) {
        client_len = sizeof(client_addr);
        client_fd = accept(server_fd, (struct sockaddr*)&client_addr, 
                          &client_len);
        if (client_fd == -1) {
            perror("accept");
            continue;
        }
        
        // åˆ†é…å®¢æˆ·ç«¯ä¿¡æ¯ç»“æ„
        client_info = malloc(sizeof(client_info_t));
        if (client_info == NULL) {
            perror("malloc");
            close(client_fd);
            continue;
        }
        
        client_info->client_fd = client_fd;
        client_info->client_addr = client_addr;
        
        // åˆ›å»ºçº¿ç¨‹å¤„ç†å®¢æˆ·ç«¯
        if (pthread_create(&thread_id, NULL, handle_client, client_info) != 0) {
            perror("pthread_create");
            free(client_info);
            close(client_fd);
            continue;
        }
        
        // åˆ†ç¦»çº¿ç¨‹ï¼Œä½¿å…¶è‡ªåŠ¨å›æ”¶èµ„æº
        pthread_detach(thread_id);
        printf("Created thread %lu for client\n", thread_id);
    }
    
    close(server_fd);
    return 0;
}
```

#### 3.3.3 çº¿ç¨‹æ¯è¿æ¥æ¨¡å‹ä¼˜åŒ–

**çº¿ç¨‹å±æ€§è®¾ç½®ï¼š**
```c
#include <pthread.h>

// è®¾ç½®çº¿ç¨‹ä¸ºåˆ†ç¦»çŠ¶æ€
pthread_attr_t attr;
pthread_attr_init(&attr);
pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

// åˆ›å»ºçº¿ç¨‹
pthread_create(&thread_id, &attr, handle_client, client_info);
pthread_attr_destroy(&attr);
```

**çº¿ç¨‹æ ˆå¤§å°è°ƒæ•´ï¼š**
```c
// è®¾ç½®çº¿ç¨‹æ ˆå¤§å°ï¼ˆé»˜è®¤å¯èƒ½è¾ƒå¤§ï¼Œå¯ä»¥å‡å°ä»¥èŠ‚çœå†…å­˜ï¼‰
size_t stack_size = 64 * 1024;  // 64KB
pthread_attr_setstacksize(&attr, stack_size);
```

#### 3.3.4 çº¿ç¨‹æ¯è¿æ¥æ¨¡å‹æ€§èƒ½åˆ†æ

| æŒ‡æ ‡ | å€¼ | è¯´æ˜ |
|------|-----|------|
| **å¹¶å‘è¿æ¥æ•°** | ä¸­ç­‰ï¼ˆ< 5000ï¼‰ | å—é™äºçº¿ç¨‹æ•°é‡ |
| **ååé‡** | ä¸­ç­‰-é«˜ | çº¿ç¨‹åˆ‡æ¢å¼€é”€è¾ƒå° |
| **å»¶è¿Ÿ** | ä½-ä¸­ç­‰ | çº¿ç¨‹åˆ›å»ºå¼€é”€è¾ƒå° |
| **èµ„æºå ç”¨** | ä¸­ç­‰ | çº¿ç¨‹å…±äº«åœ°å€ç©ºé—´ |
| **é€‚ç”¨åœºæ™¯** | ä¸­ç­‰å¹¶å‘ã€I/Oå¯†é›†å‹ | Javaä¼ ç»ŸæœåŠ¡å™¨æ¨¡å‹ |

## 4. é«˜çº§æœåŠ¡å™¨æ¨¡å‹

### 4.1 çº¿ç¨‹æ± æ¨¡å‹

çº¿ç¨‹æ± æ¨¡å‹ï¼ˆThread Poolï¼‰é¢„å…ˆåˆ›å»ºä¸€å®šæ•°é‡çš„å·¥ä½œçº¿ç¨‹ï¼Œä½¿ç”¨ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†å®¢æˆ·ç«¯è¿æ¥ï¼Œé¿å…äº†é¢‘ç¹åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹çš„å¼€é”€ã€‚

#### 4.1.1 çº¿ç¨‹æ± æ¨¡å‹ç‰¹ç‚¹

**ä¼˜ç‚¹ï¼š**
- é¿å…çº¿ç¨‹åˆ›å»ºå’Œé”€æ¯çš„å¼€é”€
- æ§åˆ¶å¹¶å‘çº¿ç¨‹æ•°é‡ï¼Œé¿å…èµ„æºè€—å°½
- æé«˜å“åº”é€Ÿåº¦ï¼ˆçº¿ç¨‹å·²å°±ç»ªï¼‰
- é€‚åˆé«˜å¹¶å‘åœºæ™¯

**ç¼ºç‚¹ï¼š**
- å®ç°å¤æ‚åº¦è¾ƒé«˜
- éœ€è¦ä»»åŠ¡é˜Ÿåˆ—å’ŒåŒæ­¥æœºåˆ¶
- çº¿ç¨‹æ•°é‡éœ€è¦åˆç†é…ç½®

**é€‚ç”¨åœºæ™¯ï¼š**
- é«˜å¹¶å‘åœºæ™¯ï¼ˆ> 1000è¿æ¥ï¼‰
- I/Oå¯†é›†å‹ä»»åŠ¡
- éœ€è¦æ§åˆ¶èµ„æºä½¿ç”¨çš„åœºæ™¯

#### 4.1.2 çº¿ç¨‹æ± æ¨¡å‹å®ç°

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>

#define PORT 8080
#define BUFFER_SIZE 1024
#define THREAD_POOL_SIZE 10
#define MAX_QUEUE_SIZE 100

// ä»»åŠ¡ç»“æ„
typedef struct task {
    int client_fd;
    struct sockaddr_in client_addr;
    struct task* next;
} task_t;

// çº¿ç¨‹æ± ç»“æ„
typedef struct {
    pthread_t* threads;
    int thread_count;
    task_t* task_queue_head;
    task_t* task_queue_tail;
    pthread_mutex_t queue_mutex;
    pthread_cond_t queue_cond;
    int shutdown;
} thread_pool_t;

thread_pool_t* pool;

// å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚
void handle_client(int client_fd, struct sockaddr_in* client_addr) {
    char buffer[BUFFER_SIZE];
    ssize_t bytes_received;
    
    printf("[Thread %lu] Handling client from %s:%d\n",
           pthread_self(),
           inet_ntoa(client_addr->sin_addr),
           ntohs(client_addr->sin_port));
    
    while (1) {
        bytes_received = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
        if (bytes_received <= 0) {
            break;
        }
        
        buffer[bytes_received] = '\0';
        printf("[Thread %lu] Received: %s", pthread_self(), buffer);
        
        // å¤„ç†è¯·æ±‚
        // è¿™é‡Œå¯ä»¥æ·»åŠ ä¸šåŠ¡é€»è¾‘
        
        // å‘é€å“åº”
        send(client_fd, buffer, bytes_received, 0);
    }
    
    close(client_fd);
    printf("[Thread %lu] Client disconnected\n", pthread_self());
}

// å·¥ä½œçº¿ç¨‹å‡½æ•°
void* worker_thread(void* arg) {
    task_t* task;
    
    while (1) {
        // è·å–ä»»åŠ¡
        pthread_mutex_lock(&pool->queue_mutex);
        
        // ç­‰å¾…ä»»åŠ¡æˆ–å…³é—­ä¿¡å·
        while (pool->task_queue_head == NULL && !pool->shutdown) {
            pthread_cond_wait(&pool->queue_cond, &pool->queue_mutex);
        }
        
        // æ£€æŸ¥æ˜¯å¦å…³é—­
        if (pool->shutdown) {
            pthread_mutex_unlock(&pool->queue_mutex);
            break;
        }
        
        // ä»é˜Ÿåˆ—å–å‡ºä»»åŠ¡
        task = pool->task_queue_head;
        if (task != NULL) {
            pool->task_queue_head = task->next;
            if (pool->task_queue_head == NULL) {
                pool->task_queue_tail = NULL;
            }
        }
        
        pthread_mutex_unlock(&pool->queue_mutex);
        
        // å¤„ç†ä»»åŠ¡
        if (task != NULL) {
            handle_client(task->client_fd, &task->client_addr);
            free(task);
        }
    }
    
    return NULL;
}

// æ·»åŠ ä»»åŠ¡åˆ°é˜Ÿåˆ—
int add_task(int client_fd, struct sockaddr_in* client_addr) {
    task_t* task = malloc(sizeof(task_t));
    if (task == NULL) {
        return -1;
    }
    
    task->client_fd = client_fd;
    task->client_addr = *client_addr;
    task->next = NULL;
    
    pthread_mutex_lock(&pool->queue_mutex);
    
    // æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦å·²æ»¡
    // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥æ£€æŸ¥é˜Ÿåˆ—å¤§å°
    
    if (pool->task_queue_tail == NULL) {
        pool->task_queue_head = task;
        pool->task_queue_tail = task;
    } else {
        pool->task_queue_tail->next = task;
        pool->task_queue_tail = task;
    }
    
    pthread_cond_signal(&pool->queue_cond);
    pthread_mutex_unlock(&pool->queue_mutex);
    
    return 0;
}

// åˆå§‹åŒ–çº¿ç¨‹æ± 
thread_pool_t* thread_pool_init(int thread_count) {
    int i;
    thread_pool_t* pool = malloc(sizeof(thread_pool_t));
    if (pool == NULL) {
        return NULL;
    }
    
    pool->threads = malloc(sizeof(pthread_t) * thread_count);
    if (pool->threads == NULL) {
        free(pool);
        return NULL;
    }
    
    pool->thread_count = thread_count;
    pool->task_queue_head = NULL;
    pool->task_queue_tail = NULL;
    pool->shutdown = 0;
    
    pthread_mutex_init(&pool->queue_mutex, NULL);
    pthread_cond_init(&pool->queue_cond, NULL);
    
    // åˆ›å»ºå·¥ä½œçº¿ç¨‹
    for (i = 0; i < thread_count; i++) {
        if (pthread_create(&pool->threads[i], NULL, worker_thread, NULL) != 0) {
            // åˆ›å»ºå¤±è´¥ï¼Œæ¸…ç†èµ„æº
            pool->shutdown = 1;
            pthread_cond_broadcast(&pool->queue_cond);
            for (int j = 0; j < i; j++) {
                pthread_join(pool->threads[j], NULL);
            }
            free(pool->threads);
            pthread_mutex_destroy(&pool->queue_mutex);
            pthread_cond_destroy(&pool->queue_cond);
            free(pool);
            return NULL;
        }
    }
    
    return pool;
}

// é”€æ¯çº¿ç¨‹æ± 
void thread_pool_destroy(thread_pool_t* pool) {
    int i;
    
    if (pool == NULL) {
        return;
    }
    
    // è®¾ç½®å…³é—­æ ‡å¿—
    pthread_mutex_lock(&pool->queue_mutex);
    pool->shutdown = 1;
    pthread_mutex_unlock(&pool->queue_mutex);
    
    // å”¤é†’æ‰€æœ‰ç­‰å¾…çš„çº¿ç¨‹
    pthread_cond_broadcast(&pool->queue_cond);
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹é€€å‡º
    for (i = 0; i < pool->thread_count; i++) {
        pthread_join(pool->threads[i], NULL);
    }
    
    // æ¸…ç†å‰©ä½™ä»»åŠ¡
    task_t* task = pool->task_queue_head;
    while (task != NULL) {
        task_t* next = task->next;
        close(task->client_fd);
        free(task);
        task = next;
    }
    
    // é”€æ¯åŒæ­¥å¯¹è±¡
    pthread_mutex_destroy(&pool->queue_mutex);
    pthread_cond_destroy(&pool->queue_cond);
    
    // é‡Šæ”¾èµ„æº
    free(pool->threads);
    free(pool);
}

int main() {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len;
    
    // åˆå§‹åŒ–çº¿ç¨‹æ± 
    pool = thread_pool_init(THREAD_POOL_SIZE);
    if (pool == NULL) {
        fprintf(stderr, "Failed to create thread pool\n");
        exit(EXIT_FAILURE);
    }
    
    printf("Thread Pool initialized with %d threads\n", THREAD_POOL_SIZE);
    
    // åˆ›å»ºå¥—æ¥å­—
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror("socket");
        thread_pool_destroy(pool);
        exit(EXIT_FAILURE);
    }
    
    // è®¾ç½®åœ°å€é‡ç”¨
    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // é…ç½®æœåŠ¡å™¨åœ°å€
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    // ç»‘å®šåœ°å€
    if (bind(server_fd, (struct sockaddr*)&server_addr, 
             sizeof(server_addr)) == -1) {
        perror("bind");
        close(server_fd);
        thread_pool_destroy(pool);
        exit(EXIT_FAILURE);
    }
    
    // å¼€å§‹ç›‘å¬
    if (listen(server_fd, 5) == -1) {
        perror("listen");
        close(server_fd);
        thread_pool_destroy(pool);
        exit(EXIT_FAILURE);
    }
    
    printf("Thread Pool Server listening on port %d\n", PORT);
    
    while (1) {
        client_len = sizeof(client_addr);
        client_fd = accept(server_fd, (struct sockaddr*)&client_addr, 
                          &client_len);
        if (client_fd == -1) {
            perror("accept");
            continue;
        }
        
        // æ·»åŠ ä»»åŠ¡åˆ°çº¿ç¨‹æ± 
        if (add_task(client_fd, &client_addr) != 0) {
            fprintf(stderr, "Failed to add task to queue\n");
            close(client_fd);
        }
    }
    
    close(server_fd);
    thread_pool_destroy(pool);
    return 0;
}
```

#### 4.1.3 çº¿ç¨‹æ± æ¨¡å‹ä¼˜åŒ–

**åŠ¨æ€çº¿ç¨‹æ± ï¼š**
æ ¹æ®ä»»åŠ¡é˜Ÿåˆ—é•¿åº¦åŠ¨æ€è°ƒæ•´çº¿ç¨‹æ•°é‡ï¼š

```c
// æœ€å°çº¿ç¨‹æ•°
#define MIN_THREADS 5
// æœ€å¤§çº¿ç¨‹æ•°
#define MAX_THREADS 50
// é˜Ÿåˆ—é•¿åº¦é˜ˆå€¼
#define QUEUE_THRESHOLD 10

void adjust_thread_pool(thread_pool_t* pool) {
    int queue_size = get_queue_size(pool);
    
    if (queue_size > QUEUE_THRESHOLD && pool->thread_count < MAX_THREADS) {
        // å¢åŠ çº¿ç¨‹
        add_worker_thread(pool);
    } else if (queue_size == 0 && pool->thread_count > MIN_THREADS) {
        // å‡å°‘çº¿ç¨‹
        remove_worker_thread(pool);
    }
}
```

**ä»»åŠ¡ä¼˜å…ˆçº§ï¼š**
ä¸ºä¸åŒç±»å‹çš„ä»»åŠ¡è®¾ç½®ä¼˜å…ˆçº§ï¼š

```c
typedef struct task {
    int client_fd;
    struct sockaddr_in client_addr;
    int priority;  // ä¼˜å…ˆçº§
    struct task* next;
} task_t;

// æŒ‰ä¼˜å…ˆçº§æ’å…¥ä»»åŠ¡
void add_task_priority(task_t* task) {
    task_t* current = pool->task_queue_head;
    task_t* prev = NULL;
    
    while (current != NULL && current->priority >= task->priority) {
        prev = current;
        current = current->next;
    }
    
    if (prev == NULL) {
        task->next = pool->task_queue_head;
        pool->task_queue_head = task;
    } else {
        task->next = prev->next;
        prev->next = task;
    }
}
```

#### 4.1.4 çº¿ç¨‹æ± æ¨¡å‹æ€§èƒ½åˆ†æ

| æŒ‡æ ‡ | å€¼ | è¯´æ˜ |
|------|-----|------|
| **å¹¶å‘è¿æ¥æ•°** | é«˜ï¼ˆ> 10000ï¼‰ | å—é™äºçº¿ç¨‹æ± å¤§å° |
| **ååé‡** | é«˜ | é¿å…çº¿ç¨‹åˆ›å»ºå¼€é”€ |
| **å»¶è¿Ÿ** | ä½ | çº¿ç¨‹å·²å°±ç»ª |
| **èµ„æºå ç”¨** | å¯æ§ | å›ºå®šçº¿ç¨‹æ•°é‡ |
| **é€‚ç”¨åœºæ™¯** | é«˜å¹¶å‘ã€I/Oå¯†é›†å‹ | Javaçº¿ç¨‹æ± ã€Nginx workerè¿›ç¨‹ |

### 4.2 è¿›ç¨‹æ± æ¨¡å‹

è¿›ç¨‹æ± æ¨¡å‹ï¼ˆProcess Pool / Preforkï¼‰é¢„å…ˆåˆ›å»ºä¸€å®šæ•°é‡çš„å·¥ä½œè¿›ç¨‹ï¼Œä¸»è¿›ç¨‹è´Ÿè´£æ¥å—è¿æ¥ï¼Œç„¶åé€šè¿‡è¿›ç¨‹é—´é€šä¿¡å°†è¿æ¥åˆ†å‘ç»™å·¥ä½œè¿›ç¨‹å¤„ç†ã€‚

#### 4.2.1 è¿›ç¨‹æ± æ¨¡å‹ç‰¹ç‚¹

**ä¼˜ç‚¹ï¼š**
- é¿å…é¢‘ç¹forkçš„å¼€é”€
- è¿›ç¨‹é—´éš”ç¦»ï¼Œç¨³å®šæ€§å¥½
- å¯ä»¥å……åˆ†åˆ©ç”¨å¤šæ ¸CPU
- é€‚åˆCPUå¯†é›†å‹ä»»åŠ¡

**ç¼ºç‚¹ï¼š**
- è¿›ç¨‹é—´é€šä¿¡å¤æ‚
- å†…å­˜å ç”¨è¾ƒé«˜
- è¿›ç¨‹åˆ‡æ¢å¼€é”€è¾ƒå¤§

**é€‚ç”¨åœºæ™¯ï¼š**
- é«˜å¹¶å‘åœºæ™¯
- CPUå¯†é›†å‹ä»»åŠ¡
- éœ€è¦è¿›ç¨‹éš”ç¦»çš„åœºæ™¯
- Apache preforkæ¨¡å¼

#### 4.2.2 è¿›ç¨‹æ± æ¨¡å‹å®ç°

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>
#include <errno.h>

#define PORT 8080
#define BUFFER_SIZE 1024
#define WORKER_PROCESSES 4
#define MAX_WORKERS 10

int server_fd;
int worker_count = 0;
pid_t workers[MAX_WORKERS];

// ä¿¡å·å¤„ç†ï¼šå›æ”¶åƒµå°¸è¿›ç¨‹
void sigchld_handler(int sig) {
    pid_t pid;
    int status;
    
    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
        printf("Worker process %d exited\n", pid);
        worker_count--;
        
        // é‡å¯å·¥ä½œè¿›ç¨‹
        if (worker_count < WORKER_PROCESSES) {
            pid_t new_pid = fork();
            if (new_pid == 0) {
                // å­è¿›ç¨‹ï¼šå¤„ç†è¿æ¥
                worker_process();
                exit(0);
            } else if (new_pid > 0) {
                workers[worker_count++] = new_pid;
                printf("Restarted worker process %d\n", new_pid);
            }
        }
    }
}

void handle_client(int client_fd) {
    char buffer[BUFFER_SIZE];
    ssize_t bytes_received;
    
    printf("[PID %d] Handling client connection\n", getpid());
    
    while (1) {
        bytes_received = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
        if (bytes_received <= 0) {
            break;
        }
        
        buffer[bytes_received] = '\0';
        printf("[PID %d] Received: %s", getpid(), buffer);
        
        // å¤„ç†è¯·æ±‚
        // è¿™é‡Œå¯ä»¥æ·»åŠ ä¸šåŠ¡é€»è¾‘
        
        // å‘é€å“åº”
        send(client_fd, buffer, bytes_received, 0);
    }
    
    close(client_fd);
    printf("[PID %d] Client disconnected\n", getpid());
}

// å·¥ä½œè¿›ç¨‹å‡½æ•°
void worker_process() {
    int client_fd;
    struct sockaddr_in client_addr;
    socklen_t client_len;
    
    printf("[Worker PID %d] Started\n", getpid());
    
    while (1) {
        client_len = sizeof(client_addr);
        client_fd = accept(server_fd, (struct sockaddr*)&client_addr, 
                          &client_len);
        if (client_fd == -1) {
            if (errno == EINTR) {
                continue;
            }
            perror("accept");
            break;
        }
        
        printf("[Worker PID %d] Client connected from %s:%d\n",
               getpid(),
               inet_ntoa(client_addr.sin_addr),
               ntohs(client_addr.sin_port));
        
        handle_client(client_fd);
    }
}

// åˆ›å»ºè¿›ç¨‹æ± 
void create_process_pool() {
    int i;
    pid_t pid;
    
    signal(SIGCHLD, sigchld_handler);
    
    for (i = 0; i < WORKER_PROCESSES; i++) {
        pid = fork();
        if (pid == 0) {
            // å­è¿›ç¨‹ï¼šå¤„ç†è¿æ¥
            worker_process();
            exit(0);
        } else if (pid > 0) {
            workers[worker_count++] = pid;
            printf("Created worker process %d\n", pid);
        } else {
            perror("fork");
            exit(EXIT_FAILURE);
        }
    }
}

int main() {
    struct sockaddr_in server_addr;
    
    // åˆ›å»ºå¥—æ¥å­—
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // è®¾ç½®åœ°å€é‡ç”¨
    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // é…ç½®æœåŠ¡å™¨åœ°å€
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    // ç»‘å®šåœ°å€
    if (bind(server_fd, (struct sockaddr*)&server_addr, 
             sizeof(server_addr)) == -1) {
        perror("bind");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    // å¼€å§‹ç›‘å¬
    if (listen(server_fd, 5) == -1) {
        perror("listen");
        close(server_fd);
        exit(EXIT_FAILURE);
    }
    
    printf("Process Pool Server listening on port %d\n", PORT);
    printf("Main process PID: %d\n", getpid());
    
    // åˆ›å»ºè¿›ç¨‹æ± 
    create_process_pool();
    
    // ä¸»è¿›ç¨‹ï¼šç­‰å¾…æ‰€æœ‰å·¥ä½œè¿›ç¨‹
    while (worker_count > 0) {
        pause();
    }
    
    close(server_fd);
    return 0;
}
```

#### 4.2.3 è¿›ç¨‹æ± æ¨¡å‹ä¼˜åŒ–

**å…±äº«å¥—æ¥å­—ï¼ˆSO_REUSEPORTï¼‰ï¼š**
ä½¿ç”¨SO_REUSEPORTé€‰é¡¹ï¼Œè®©å¤šä¸ªè¿›ç¨‹å…±äº«åŒä¸€ä¸ªç«¯å£ï¼š

```c
// è®¾ç½®SO_REUSEPORTé€‰é¡¹
int opt = 1;
setsockopt(server_fd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));

// æ¯ä¸ªå·¥ä½œè¿›ç¨‹éƒ½ç»‘å®šåŒä¸€ä¸ªç«¯å£
// å†…æ ¸ä¼šè‡ªåŠ¨è¿›è¡Œè´Ÿè½½å‡è¡¡
```

**è¿›ç¨‹é—´é€šä¿¡ä¼˜åŒ–ï¼š**
ä½¿ç”¨å…±äº«å†…å­˜æˆ–æ¶ˆæ¯é˜Ÿåˆ—è¿›è¡Œè¿›ç¨‹é—´é€šä¿¡ï¼š

```c
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/msg.h>

// ä½¿ç”¨å…±äº«å†…å­˜
int shm_id = shmget(IPC_PRIVATE, sizeof(shared_data), IPC_CREAT | 0666);
shared_data* data = (shared_data*)shmat(shm_id, NULL, 0);

// ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—
int msg_id = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
msgsnd(msg_id, &message, sizeof(message), 0);
```

#### 4.2.4 è¿›ç¨‹æ± æ¨¡å‹æ€§èƒ½åˆ†æ

| æŒ‡æ ‡ | å€¼ | è¯´æ˜ |
|------|-----|------|
| **å¹¶å‘è¿æ¥æ•°** | é«˜ï¼ˆ> 5000ï¼‰ | å—é™äºè¿›ç¨‹æ•°é‡ |
| **ååé‡** | é«˜ | é¿å…forkå¼€é”€ |
| **å»¶è¿Ÿ** | ä¸­ç­‰ | è¿›ç¨‹åˆ‡æ¢å¼€é”€ |
| **èµ„æºå ç”¨** | é«˜ | æ¯ä¸ªè¿›ç¨‹ç‹¬ç«‹å†…å­˜ç©ºé—´ |
| **é€‚ç”¨åœºæ™¯** | é«˜å¹¶å‘ã€CPUå¯†é›†å‹ | Apache preforkã€Nginx worker |

## 5. äº‹ä»¶é©±åŠ¨æ¶æ„

### 5.1 äº‹ä»¶é©±åŠ¨æ¶æ„æ¦‚è¿°

äº‹ä»¶é©±åŠ¨æ¶æ„ï¼ˆEvent-Driven Architectureï¼‰æ˜¯é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡å™¨çš„æ ¸å¿ƒè®¾è®¡æ¨¡å¼ï¼Œé€šè¿‡äº‹ä»¶å¾ªç¯å’Œå›è°ƒæœºåˆ¶å¤„ç†I/Oæ“ä½œï¼Œé¿å…äº†çº¿ç¨‹/è¿›ç¨‹åˆ‡æ¢çš„å¼€é”€ã€‚

#### 5.1.1 äº‹ä»¶é©±åŠ¨æ¶æ„ç‰¹ç‚¹

**ä¼˜ç‚¹ï¼š**
- é«˜å¹¶å‘èƒ½åŠ›ï¼ˆå¯å¤„ç†æ•°ä¸‡è¿æ¥ï¼‰
- ä½èµ„æºå ç”¨ï¼ˆå•çº¿ç¨‹/å°‘é‡çº¿ç¨‹ï¼‰
- ä½å»¶è¿Ÿï¼ˆæ— çº¿ç¨‹åˆ‡æ¢ï¼‰
- é€‚åˆI/Oå¯†é›†å‹åº”ç”¨

**ç¼ºç‚¹ï¼š**
- ä¸é€‚åˆCPUå¯†é›†å‹ä»»åŠ¡
- ç¼–ç¨‹å¤æ‚åº¦è¾ƒé«˜
- éœ€è¦éé˜»å¡I/Oæ”¯æŒ

**é€‚ç”¨åœºæ™¯ï¼š**
- é«˜å¹¶å‘WebæœåŠ¡å™¨
- å®æ—¶é€šä¿¡ç³»ç»Ÿ
- I/Oå¯†é›†å‹åº”ç”¨
- Node.jsã€Nginxã€Redisç­‰

#### 5.1.2 äº‹ä»¶é©±åŠ¨æ¶æ„åˆ†ç±»

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  äº‹ä»¶é©±åŠ¨æ¶æ„åˆ†ç±»                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ”„ Reactoræ¨¡å¼                                              â”‚
â”‚  â”œâ”€â”€ å•Reactorå•çº¿ç¨‹                                         â”‚
â”‚  â”œâ”€â”€ å•Reactorå¤šçº¿ç¨‹                                         â”‚
â”‚  â””â”€â”€ å¤šReactorå¤šçº¿ç¨‹                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  âš¡ Proactoræ¨¡å¼                                             â”‚
â”‚  â”œâ”€â”€ å¼‚æ­¥I/Oå®Œæˆ                                             â”‚
â”‚  â”œâ”€â”€ æ“ä½œç³»ç»Ÿå®ŒæˆI/Oæ“ä½œ                                     â”‚
â”‚  â””â”€â”€ å›è°ƒé€šçŸ¥åº”ç”¨å±‚                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 Reactoræ¨¡å¼

Reactoræ¨¡å¼æ˜¯äº‹ä»¶é©±åŠ¨æ¶æ„çš„æ ¸å¿ƒï¼Œé€šè¿‡äº‹ä»¶åˆ†å‘å™¨ï¼ˆEvent Demultiplexerï¼‰ç›‘å¬å¤šä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œå½“I/Oäº‹ä»¶å°±ç»ªæ—¶ï¼Œé€šçŸ¥ç›¸åº”çš„å¤„ç†å™¨è¿›è¡Œå¤„ç†ã€‚

#### 5.2.1 Reactoræ¨¡å¼ç»„ä»¶

**Reactoræ¨¡å¼åŒ…å«ä»¥ä¸‹ç»„ä»¶ï¼š**

1. **Event Demultiplexerï¼ˆäº‹ä»¶åˆ†å‘å™¨ï¼‰**ï¼š
   - select/poll/epollç­‰I/Oå¤šè·¯å¤ç”¨æœºåˆ¶
   - ç›‘å¬æ–‡ä»¶æè¿°ç¬¦çš„I/Oäº‹ä»¶

2. **Event Handlerï¼ˆäº‹ä»¶å¤„ç†å™¨ï¼‰**ï¼š
   - å¤„ç†å…·ä½“çš„I/Oäº‹ä»¶
   - åŒ…å«å›è°ƒå‡½æ•°

3. **Reactorï¼ˆååº”å™¨ï¼‰**ï¼š
   - äº‹ä»¶å¾ªç¯
   - åˆ†å‘äº‹ä»¶åˆ°ç›¸åº”çš„å¤„ç†å™¨

4. **Acceptorï¼ˆæ¥å—å™¨ï¼‰**ï¼š
   - å¤„ç†æ–°è¿æ¥äº‹ä»¶
   - åˆ›å»ºæ–°çš„è¿æ¥å¤„ç†å™¨

#### 5.2.2 å•Reactorå•çº¿ç¨‹æ¨¡å‹

**æ¶æ„å›¾ï¼š**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     å•Reactorå•çº¿ç¨‹                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Main Thread                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Reactor (Event Loop)                               â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ epoll_wait()                                   â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ äº‹ä»¶åˆ†å‘                                        â”‚    â”‚
â”‚  â”‚  â””â”€â”€ è°ƒç”¨Handler                                     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚              â”‚              â”‚                      â”‚
â”‚         â–¼              â–¼              â–¼                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ Acceptor â”‚   â”‚ Handler1 â”‚   â”‚ Handler2 â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å®ç°ç¤ºä¾‹ï¼š**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <fcntl.h>

#define PORT 8080
#define BUFFER_SIZE 1024
#define MAX_EVENTS 1000

// äº‹ä»¶å¤„ç†å™¨æ¥å£
typedef struct event_handler {
    int fd;
    void (*handle_read)(struct event_handler* self);
    void (*handle_write)(struct event_handler* self);
    void (*handle_error)(struct event_handler* self);
} event_handler_t;

// Acceptorå¤„ç†å™¨
typedef struct {
    event_handler_t base;
    int server_fd;
} acceptor_t;

// Connectionå¤„ç†å™¨
typedef struct {
    event_handler_t base;
    char buffer[BUFFER_SIZE];
    int buffer_len;
} connection_t;

// Reactorç»“æ„
typedef struct {
    int epoll_fd;
    struct epoll_event events[MAX_EVENTS];
    event_handler_t* handlers[MAX_EVENTS];
    int handler_count;
} reactor_t;

reactor_t reactor;

// Acceptorå¤„ç†æ–°è¿æ¥
void acceptor_handle_read(event_handler_t* handler) {
    acceptor_t* acceptor = (acceptor_t*)handler;
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);
    int client_fd;
    connection_t* conn;
    struct epoll_event event;
    
    client_fd = accept(acceptor->server_fd, 
                      (struct sockaddr*)&client_addr, &client_len);
    if (client_fd == -1) {
        perror("accept");
        return;
    }
    
    // è®¾ç½®éé˜»å¡
    int flags = fcntl(client_fd, F_GETFL, 0);
    fcntl(client_fd, F_SETFL, flags | O_NONBLOCK);
    
    // åˆ›å»ºè¿æ¥å¤„ç†å™¨
    conn = malloc(sizeof(connection_t));
    memset(conn, 0, sizeof(connection_t));
    conn->base.fd = client_fd;
    conn->base.handle_read = connection_handle_read;
    conn->base.handle_write = connection_handle_write;
    conn->base.handle_error = connection_handle_error;
    
    // æ·»åŠ åˆ°epoll
    event.events = EPOLLIN | EPOLLET;
    event.data.ptr = &conn->base;
    epoll_ctl(reactor.epoll_fd, EPOLL_CTL_ADD, client_fd, &event);
    
    printf("New client connected: %s:%d\n",
           inet_ntoa(client_addr.sin_addr),
           ntohs(client_addr.sin_port));
}

// Connectionå¤„ç†è¯»äº‹ä»¶
void connection_handle_read(event_handler_t* handler) {
    connection_t* conn = (connection_t*)handler;
    ssize_t bytes_received;
    
    bytes_received = recv(conn->base.fd, conn->buffer, BUFFER_SIZE - 1, 0);
    if (bytes_received > 0) {
        conn->buffer[bytes_received] = '\0';
        conn->buffer_len = bytes_received;
        printf("Received: %s", conn->buffer);
        
        // å›æ˜¾æ•°æ®
        send(conn->base.fd, conn->buffer, bytes_received, 0);
    } else if (bytes_received == 0) {
        printf("Client disconnected\n");
        connection_handle_error(handler);
    } else {
        if (errno != EAGAIN && errno != EWOULDBLOCK) {
            perror("recv");
            connection_handle_error(handler);
        }
    }
}

// Connectionå¤„ç†å†™äº‹ä»¶
void connection_handle_write(event_handler_t* handler) {
    // å†™äº‹ä»¶å¤„ç†
    connection_t* conn = (connection_t*)handler;
    // å®ç°å†™é€»è¾‘
}

// Connectionå¤„ç†é”™è¯¯
void connection_handle_error(event_handler_t* handler) {
    connection_t* conn = (connection_t*)handler;
    epoll_ctl(reactor.epoll_fd, EPOLL_CTL_DEL, conn->base.fd, NULL);
    close(conn->base.fd);
    free(conn);
}

// Reactoräº‹ä»¶å¾ªç¯
void reactor_run() {
    int nfds, i;
    event_handler_t* handler;
    
    while (1) {
        nfds = epoll_wait(reactor.epoll_fd, reactor.events, MAX_EVENTS, -1);
        if (nfds == -1) {
            perror("epoll_wait");
            break;
        }
        
        for (i = 0; i < nfds; i++) {
            handler = (event_handler_t*)reactor.events[i].data.ptr;
            
            if (reactor.events[i].events & EPOLLIN) {
                handler->handle_read(handler);
            }
            if (reactor.events[i].events & EPOLLOUT) {
                handler->handle_write(handler);
            }
            if (reactor.events[i].events & (EPOLLERR | EPOLLHUP)) {
                handler->handle_error(handler);
            }
        }
    }
}

int main() {
    int server_fd;
    struct sockaddr_in server_addr;
    struct epoll_event event;
    acceptor_t* acceptor;
    
    // åˆ›å»ºepoll
    reactor.epoll_fd = epoll_create1(0);
    if (reactor.epoll_fd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }
    
    // åˆ›å»ºæœåŠ¡å™¨å¥—æ¥å­—
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // è®¾ç½®éé˜»å¡
    int flags = fcntl(server_fd, F_GETFL, 0);
    fcntl(server_fd, F_SETFL, flags | O_NONBLOCK);
    
    // è®¾ç½®åœ°å€é‡ç”¨
    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // é…ç½®æœåŠ¡å™¨åœ°å€
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    // ç»‘å®šå’Œç›‘å¬
    if (bind(server_fd, (struct sockaddr*)&server_addr, 
             sizeof(server_addr)) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }
    
    if (listen(server_fd, 5) == -1) {
        perror("listen");
        exit(EXIT_FAILURE);
    }
    
    // åˆ›å»ºAcceptor
    acceptor = malloc(sizeof(acceptor_t));
    memset(acceptor, 0, sizeof(acceptor_t));
    acceptor->base.fd = server_fd;
    acceptor->base.handle_read = acceptor_handle_read;
    acceptor->server_fd = server_fd;
    
    // æ·»åŠ æœåŠ¡å™¨å¥—æ¥å­—åˆ°epoll
    event.events = EPOLLIN;
    event.data.ptr = &acceptor->base;
    epoll_ctl(reactor.epoll_fd, EPOLL_CTL_ADD, server_fd, &event);
    
    printf("Single Reactor Single Thread Server listening on port %d\n", PORT);
    
    // è¿è¡Œäº‹ä»¶å¾ªç¯
    reactor_run();
    
    close(server_fd);
    close(reactor.epoll_fd);
    return 0;
}
```

#### 5.2.3 å•Reactorå¤šçº¿ç¨‹æ¨¡å‹

**æ¶æ„å›¾ï¼š**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     å•Reactorå¤šçº¿ç¨‹                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Main Thread (Reactor)                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Event Loop                                         â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ æ¥å—è¿æ¥                                        â”‚    â”‚
â”‚  â”‚  â””â”€â”€ åˆ†å‘I/Oäº‹ä»¶åˆ°çº¿ç¨‹æ±                              â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚                                                    â”‚
â”‚         â–¼                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Thread Pool                                         â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ Worker Thread 1                                 â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ Worker Thread 2                                 â”‚    â”‚
â”‚  â”‚  â””â”€â”€ Worker Thread N                                 â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç‰¹ç‚¹ï¼š**
- Reactorçº¿ç¨‹è´Ÿè´£æ¥å—è¿æ¥å’ŒI/Oäº‹ä»¶åˆ†å‘
- å·¥ä½œçº¿ç¨‹æ± å¤„ç†ä¸šåŠ¡é€»è¾‘
- é€‚åˆCPUå¯†é›†å‹ä»»åŠ¡

#### 5.2.4 å¤šReactorå¤šçº¿ç¨‹æ¨¡å‹

**æ¶æ„å›¾ï¼š**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     å¤šReactorå¤šçº¿ç¨‹                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Main Reactor (Main Thread)                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  æ¥å—æ–°è¿æ¥ï¼Œåˆ†å‘ç»™Sub Reactor                        â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚                                                    â”‚
â”‚         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚         â–¼              â–¼              â–¼              â–¼      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚Sub Reactorâ”‚   â”‚Sub Reactorâ”‚   â”‚Sub Reactorâ”‚   â”‚Sub Reactorâ”‚â”‚
â”‚  â”‚(Thread 1) â”‚   â”‚(Thread 2) â”‚   â”‚(Thread 3) â”‚   â”‚(Thread N) â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç‰¹ç‚¹ï¼š**
- Main Reactorè´Ÿè´£æ¥å—è¿æ¥
- Sub Reactorè´Ÿè´£å¤„ç†I/Oäº‹ä»¶
- æ¯ä¸ªSub Reactorè¿è¡Œåœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­
- é€‚åˆé«˜å¹¶å‘åœºæ™¯ï¼ˆNettyã€Muduoç­‰ï¼‰

#### 5.2.5 Reactoræ¨¡å¼æ€§èƒ½åˆ†æ

| æ¨¡å‹ | å¹¶å‘è¿æ¥æ•° | ååé‡ | å»¶è¿Ÿ | é€‚ç”¨åœºæ™¯ |
|------|-----------|--------|------|----------|
| **å•Reactorå•çº¿ç¨‹** | é«˜ï¼ˆ> 10000ï¼‰ | é«˜ | ä½ | I/Oå¯†é›†å‹ã€Redis |
| **å•Reactorå¤šçº¿ç¨‹** | é«˜ï¼ˆ> 10000ï¼‰ | é«˜ | ä½ | I/O+CPUæ··åˆ |
| **å¤šReactorå¤šçº¿ç¨‹** | æé«˜ï¼ˆ> 50000ï¼‰ | æé«˜ | æä½ | é«˜å¹¶å‘ã€Netty |

### 5.3 Proactoræ¨¡å¼

Proactoræ¨¡å¼æ˜¯å¦ä¸€ç§äº‹ä»¶é©±åŠ¨æ¶æ„ï¼Œä¸Reactoræ¨¡å¼çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼šProactoræ¨¡å¼ä¸­ï¼Œåº”ç”¨ç¨‹åºå‘èµ·å¼‚æ­¥I/Oæ“ä½œï¼Œæ“ä½œç³»ç»Ÿå®ŒæˆI/Oæ“ä½œåé€šçŸ¥åº”ç”¨ç¨‹åºã€‚

#### 5.3.1 Proactoræ¨¡å¼ç‰¹ç‚¹

**ä¸Reactoræ¨¡å¼å¯¹æ¯”ï¼š**

| ç‰¹æ€§ | Reactoræ¨¡å¼ | Proactoræ¨¡å¼ |
|------|------------|-------------|
| **I/Oæ“ä½œ** | åº”ç”¨ç¨‹åºå®Œæˆ | æ“ä½œç³»ç»Ÿå®Œæˆ |
| **é€šçŸ¥æ—¶æœº** | I/Oå°±ç»ªæ—¶é€šçŸ¥ | I/Oå®Œæˆæ—¶é€šçŸ¥ |
| **ç¼–ç¨‹å¤æ‚åº¦** | ä¸­ç­‰ | è¾ƒé«˜ |
| **æ€§èƒ½** | é«˜ | æé«˜ |
| **å®ç°æ–¹å¼** | epoll/select | io_uring/aio |

**ä¼˜ç‚¹ï¼š**
- æ›´é«˜çš„æ€§èƒ½ï¼ˆé›¶æ‹·è´ã€å¼‚æ­¥I/Oï¼‰
- å‡å°‘ç³»ç»Ÿè°ƒç”¨æ¬¡æ•°
- æ›´å¥½çš„CPUåˆ©ç”¨ç‡

**ç¼ºç‚¹ï¼š**
- ç¼–ç¨‹å¤æ‚åº¦é«˜
- éœ€è¦æ“ä½œç³»ç»Ÿæ”¯æŒï¼ˆLinux io_uringï¼‰
- è°ƒè¯•å›°éš¾

#### 5.3.2 Proactoræ¨¡å¼å®ç°ï¼ˆio_uringï¼‰

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <liburing.h>
#include <fcntl.h>

#define PORT 8080
#define BUFFER_SIZE 1024
#define QUEUE_DEPTH 256

// è¿æ¥ä¿¡æ¯
typedef struct {
    int fd;
    char buffer[BUFFER_SIZE];
    int buffer_len;
} connection_t;

// åˆå§‹åŒ–io_uring
int setup_uring(struct io_uring* ring) {
    int ret = io_uring_queue_init(QUEUE_DEPTH, ring, 0);
    if (ret < 0) {
        fprintf(stderr, "io_uring_queue_init failed: %s\n", strerror(-ret));
        return -1;
    }
    return 0;
}

// æäº¤acceptè¯·æ±‚
void submit_accept(struct io_uring* ring, int server_fd) {
    struct io_uring_sqe* sqe = io_uring_get_sqe(ring);
    io_uring_prep_accept(sqe, server_fd, NULL, NULL, 0);
    
    connection_t* conn = malloc(sizeof(connection_t));
    io_uring_sqe_set_data(sqe, conn);
    
    io_uring_submit(ring);
}

// æäº¤recvè¯·æ±‚
void submit_recv(struct io_uring* ring, connection_t* conn) {
    struct io_uring_sqe* sqe = io_uring_get_sqe(ring);
    io_uring_prep_recv(sqe, conn->fd, conn->buffer, BUFFER_SIZE, 0);
    io_uring_sqe_set_data(sqe, conn);
    io_uring_submit(ring);
}

// æäº¤sendè¯·æ±‚
void submit_send(struct io_uring* ring, connection_t* conn, int len) {
    struct io_uring_sqe* sqe = io_uring_get_sqe(ring);
    io_uring_prep_send(sqe, conn->fd, conn->buffer, len, 0);
    io_uring_sqe_set_data(sqe, conn);
    io_uring_submit(ring);
}

int main() {
    struct io_uring ring;
    struct io_uring_cqe* cqe;
    int server_fd;
    struct sockaddr_in server_addr;
    connection_t* conn;
    int ret;
    
    // åˆå§‹åŒ–io_uring
    if (setup_uring(&ring) < 0) {
        exit(EXIT_FAILURE);
    }
    
    // åˆ›å»ºæœåŠ¡å™¨å¥—æ¥å­—
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // è®¾ç½®éé˜»å¡
    int flags = fcntl(server_fd, F_GETFL, 0);
    fcntl(server_fd, F_SETFL, flags | O_NONBLOCK);
    
    // è®¾ç½®åœ°å€é‡ç”¨
    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // é…ç½®æœåŠ¡å™¨åœ°å€
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    // ç»‘å®šå’Œç›‘å¬
    if (bind(server_fd, (struct sockaddr*)&server_addr, 
             sizeof(server_addr)) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }
    
    if (listen(server_fd, 5) == -1) {
        perror("listen");
        exit(EXIT_FAILURE);
    }
    
    printf("Proactor Server (io_uring) listening on port %d\n", PORT);
    
    // æäº¤åˆå§‹acceptè¯·æ±‚
    submit_accept(&ring, server_fd);
    
    // äº‹ä»¶å¾ªç¯
    while (1) {
        // ç­‰å¾…å®Œæˆäº‹ä»¶
        ret = io_uring_wait_cqe(&ring, &cqe);
        if (ret < 0) {
            fprintf(stderr, "io_uring_wait_cqe failed\n");
            break;
        }
        
        conn = (connection_t*)io_uring_cqe_get_data(cqe);
        
        if (cqe->res < 0) {
            fprintf(stderr, "Async operation failed: %s\n", strerror(-cqe->res));
            if (conn->fd != server_fd) {
                close(conn->fd);
                free(conn);
            }
        } else if (conn->fd == server_fd) {
            // æ–°è¿æ¥
            int client_fd = cqe->res;
            printf("New client connected: fd=%d\n", client_fd);
            
            // è®¾ç½®éé˜»å¡
            flags = fcntl(client_fd, F_GETFL, 0);
            fcntl(client_fd, F_SETFL, flags | O_NONBLOCK);
            
            // åˆ›å»ºè¿æ¥å¯¹è±¡
            conn = malloc(sizeof(connection_t));
            memset(conn, 0, sizeof(connection_t));
            conn->fd = client_fd;
            
            // æäº¤recvè¯·æ±‚
            submit_recv(&ring, conn);
            
            // ç»§ç»­æ¥å—æ–°è¿æ¥
            submit_accept(&ring, server_fd);
        } else {
            // I/Oæ“ä½œå®Œæˆ
            if (cqe->res > 0) {
                // æ•°æ®æ¥æ”¶å®Œæˆ
                conn->buffer_len = cqe->res;
                conn->buffer[conn->buffer_len] = '\0';
                printf("Received: %s", conn->buffer);
                
                // æäº¤sendè¯·æ±‚
                submit_send(&ring, conn, conn->buffer_len);
            } else if (cqe->res == 0) {
                // è¿æ¥å…³é—­
                printf("Client disconnected\n");
                close(conn->fd);
                free(conn);
            } else {
                // å‘é€å®Œæˆï¼Œç»§ç»­æ¥æ”¶
                submit_recv(&ring, conn);
            }
        }
        
        io_uring_cqe_seen(&ring, cqe);
    }
    
    close(server_fd);
    io_uring_queue_exit(&ring);
    return 0;
}
```

#### 5.3.3 Proactoræ¨¡å¼æ€§èƒ½åˆ†æ

| æŒ‡æ ‡ | å€¼ | è¯´æ˜ |
|------|-----|------|
| **å¹¶å‘è¿æ¥æ•°** | æé«˜ï¼ˆ> 100000ï¼‰ | å—é™äºç³»ç»Ÿèµ„æº |
| **ååé‡** | æé«˜ | é›¶æ‹·è´ã€å¼‚æ­¥I/O |
| **å»¶è¿Ÿ** | æä½ | å‡å°‘ç³»ç»Ÿè°ƒç”¨ |
| **èµ„æºå ç”¨** | ä½ | å•çº¿ç¨‹/å°‘é‡çº¿ç¨‹ |
| **é€‚ç”¨åœºæ™¯** | è¶…é«˜å¹¶å‘ã€é«˜æ€§èƒ½ | io_uringã€Windows IOCP |

## 6. è´Ÿè½½å‡è¡¡ä¸ä»£ç†

### 6.1 è´Ÿè½½å‡è¡¡æ¦‚è¿°

è´Ÿè½½å‡è¡¡ï¼ˆLoad Balancingï¼‰æ˜¯å°†ç½‘ç»œè¯·æ±‚åˆ†å‘åˆ°å¤šä¸ªæœåŠ¡å™¨ä¸Šï¼Œä»¥æé«˜ç³»ç»Ÿçš„å¯ç”¨æ€§ã€æ‰©å±•æ€§å’Œæ€§èƒ½ã€‚

#### 6.1.1 è´Ÿè½½å‡è¡¡åˆ†ç±»

**æŒ‰å±‚æ¬¡åˆ†ç±»ï¼š**

1. **DNSè´Ÿè½½å‡è¡¡**ï¼š
   - åœ¨DNSå±‚é¢è¿›è¡Œè´Ÿè½½å‡è¡¡
   - è¿”å›ä¸åŒçš„IPåœ°å€
   - ç®€å•ä½†ä¸å¤Ÿçµæ´»

2. **å››å±‚è´Ÿè½½å‡è¡¡ï¼ˆL4ï¼‰**ï¼š
   - åŸºäºIPå’Œç«¯å£
   - TCP/UDPåè®®
   - æ€§èƒ½é«˜ï¼Œä½†åŠŸèƒ½æœ‰é™

3. **ä¸ƒå±‚è´Ÿè½½å‡è¡¡ï¼ˆL7ï¼‰**ï¼š
   - åŸºäºHTTP/HTTPSåè®®
   - å¯ä»¥åŸºäºURLã€Headerç­‰
   - åŠŸèƒ½å¼ºå¤§ï¼Œä½†æ€§èƒ½è¾ƒä½

**æŒ‰å®ç°æ–¹å¼åˆ†ç±»ï¼š**

1. **ç¡¬ä»¶è´Ÿè½½å‡è¡¡**ï¼š
   - F5ã€A10ç­‰ä¸“ç”¨è®¾å¤‡
   - æ€§èƒ½æé«˜ï¼Œä½†æˆæœ¬é«˜

2. **è½¯ä»¶è´Ÿè½½å‡è¡¡**ï¼š
   - Nginxã€HAProxyã€LVS
   - æˆæœ¬ä½ï¼Œé…ç½®çµæ´»

### 6.2 è´Ÿè½½å‡è¡¡ç®—æ³•

#### 6.2.1 è½®è¯¢ï¼ˆRound Robinï¼‰

**åŸç†ï¼š**
æŒ‰é¡ºåºå°†è¯·æ±‚åˆ†å‘åˆ°å„ä¸ªæœåŠ¡å™¨ã€‚

**å®ç°ï¼š**
```c
typedef struct {
    char* server_addr;
    int port;
    int weight;
    int current_connections;
} backend_server_t;

backend_server_t servers[] = {
    {"192.168.1.10", 8080, 1, 0},
    {"192.168.1.11", 8080, 1, 0},
    {"192.168.1.12", 8080, 1, 0},
};

int current_index = 0;

backend_server_t* round_robin_select() {
    backend_server_t* server = &servers[current_index];
    current_index = (current_index + 1) % 3;
    return server;
}
```

#### 6.2.2 åŠ æƒè½®è¯¢ï¼ˆWeighted Round Robinï¼‰

**åŸç†ï¼š**
æ ¹æ®æœåŠ¡å™¨æƒé‡è¿›è¡Œè½®è¯¢ï¼Œæƒé‡é«˜çš„æœåŠ¡å™¨è·å¾—æ›´å¤šè¯·æ±‚ã€‚

**å®ç°ï¼š**
```c
int total_weight = 0;
int current_weight = 0;

backend_server_t* weighted_round_robin_select() {
    int max_weight = -1;
    int selected_index = 0;
    
    // è®¡ç®—æ€»æƒé‡
    for (int i = 0; i < 3; i++) {
        total_weight += servers[i].weight;
        int weight = servers[i].weight + servers[i].current_connections;
        if (weight > max_weight) {
            max_weight = weight;
            selected_index = i;
        }
    }
    
    servers[selected_index].current_connections++;
    return &servers[selected_index];
}
```

#### 6.2.3 æœ€å°‘è¿æ¥ï¼ˆLeast Connectionsï¼‰

**åŸç†ï¼š**
å°†è¯·æ±‚åˆ†å‘åˆ°å½“å‰è¿æ¥æ•°æœ€å°‘çš„æœåŠ¡å™¨ã€‚

**å®ç°ï¼š**
```c
backend_server_t* least_connections_select() {
    int min_connections = INT_MAX;
    int selected_index = 0;
    
    for (int i = 0; i < 3; i++) {
        if (servers[i].current_connections < min_connections) {
            min_connections = servers[i].current_connections;
            selected_index = i;
        }
    }
    
    servers[selected_index].current_connections++;
    return &servers[selected_index];
}
```

#### 6.2.4 IPå“ˆå¸Œï¼ˆIP Hashï¼‰

**åŸç†ï¼š**
æ ¹æ®å®¢æˆ·ç«¯IPåœ°å€è®¡ç®—å“ˆå¸Œå€¼ï¼Œå°†åŒä¸€IPçš„è¯·æ±‚åˆ†å‘åˆ°åŒä¸€æœåŠ¡å™¨ã€‚

**å®ç°ï¼š**
```c
unsigned int hash_ip(const char* ip) {
    unsigned int hash = 0;
    for (int i = 0; ip[i] != '\0'; i++) {
        hash = hash * 31 + ip[i];
    }
    return hash;
}

backend_server_t* ip_hash_select(const char* client_ip) {
    unsigned int hash = hash_ip(client_ip);
    int selected_index = hash % 3;
    return &servers[selected_index];
}
```

### 6.3 åå‘ä»£ç†

åå‘ä»£ç†ï¼ˆReverse Proxyï¼‰æ˜¯è´Ÿè½½å‡è¡¡çš„ä¸€ç§å®ç°æ–¹å¼ï¼Œä»£ç†æœåŠ¡å™¨æ¥æ”¶å®¢æˆ·ç«¯è¯·æ±‚ï¼Œç„¶åè½¬å‘åˆ°åç«¯æœåŠ¡å™¨ã€‚

#### 6.3.1 åå‘ä»£ç†æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client 1 â”‚â”€â”€â”€â”€â”€â–¶â”‚              â”‚â”€â”€â”€â”€â”€â–¶â”‚ Server 1 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚              â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ Reverse Proxyâ”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚   (Nginx)    â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client 2 â”‚â”€â”€â”€â”€â”€â–¶â”‚              â”‚â”€â”€â”€â”€â”€â–¶â”‚ Server 2 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚              â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                      â”‚
â”‚ Client 3 â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 6.3.2 åå‘ä»£ç†å®ç°è¦ç‚¹

**è¿æ¥ç®¡ç†ï¼š**
- ä¿æŒè¿æ¥æ± 
- å¤ç”¨åç«¯è¿æ¥
- è¶…æ—¶å¤„ç†

**å¥åº·æ£€æŸ¥ï¼š**
- å®šæœŸæ£€æŸ¥åç«¯æœåŠ¡å™¨çŠ¶æ€
- è‡ªåŠ¨å‰”é™¤æ•…éšœæœåŠ¡å™¨
- è‡ªåŠ¨æ¢å¤å¯ç”¨æœåŠ¡å™¨

**SSLç»ˆæ­¢ï¼š**
- åœ¨ä»£ç†æœåŠ¡å™¨ä¸Šç»ˆæ­¢SSL
- å‡è½»åç«¯æœåŠ¡å™¨è´Ÿæ‹…
- ç»Ÿä¸€è¯ä¹¦ç®¡ç†

### 6.4 æœåŠ¡å™¨æ¶æ„é€‰æ‹©å»ºè®®

#### 6.4.1 æ¶æ„é€‰æ‹©å†³ç­–æ ‘

```
å¼€å§‹
  â”‚
  â”œâ”€ å¹¶å‘è¿æ¥æ•° < 100?
  â”‚   â””â”€ æ˜¯ â†’ ä¸²è¡ŒæœåŠ¡å™¨
  â”‚   â””â”€ å¦ â†“
  â”‚
  â”œâ”€ å¹¶å‘è¿æ¥æ•° < 1000?
  â”‚   â””â”€ æ˜¯ â†’ è¿›ç¨‹/çº¿ç¨‹æ¯è¿æ¥æ¨¡å‹
  â”‚   â””â”€ å¦ â†“
  â”‚
  â”œâ”€ ä»»åŠ¡ç±»å‹?
  â”‚   â”œâ”€ CPUå¯†é›†å‹ â†’ è¿›ç¨‹æ± /çº¿ç¨‹æ± æ¨¡å‹
  â”‚   â””â”€ I/Oå¯†é›†å‹ â†“
  â”‚
  â”œâ”€ å¹¶å‘è¿æ¥æ•° < 10000?
  â”‚   â””â”€ æ˜¯ â†’ å•Reactorå•çº¿ç¨‹
  â”‚   â””â”€ å¦ â†“
  â”‚
  â”œâ”€ éœ€è¦CPUå¤„ç†?
  â”‚   â””â”€ æ˜¯ â†’ å•Reactorå¤šçº¿ç¨‹
  â”‚   â””â”€ å¦ â†“
  â”‚
  â””â”€ è¶…é«˜å¹¶å‘?
      â””â”€ æ˜¯ â†’ å¤šReactorå¤šçº¿ç¨‹ / Proactoræ¨¡å¼
```

#### 6.4.2 å®é™…åº”ç”¨æ¡ˆä¾‹

| åº”ç”¨ | æ¶æ„æ¨¡å‹ | è¯´æ˜ |
|------|---------|------|
| **Redis** | å•Reactorå•çº¿ç¨‹ | I/Oå¯†é›†å‹ï¼Œå•çº¿ç¨‹å¤„ç†æ‰€æœ‰è¯·æ±‚ |
| **Nginx** | å¤šè¿›ç¨‹ + epoll | æ¯ä¸ªworkerè¿›ç¨‹ä¸€ä¸ªäº‹ä»¶å¾ªç¯ |
| **Netty** | å¤šReactorå¤šçº¿ç¨‹ | Main Reactor + Sub Reactor |
| **Apache** | è¿›ç¨‹æ± /çº¿ç¨‹æ±  | Prefork/Workeræ¨¡å¼ |
| **Node.js** | å•Reactorå•çº¿ç¨‹ + çº¿ç¨‹æ±  | äº‹ä»¶å¾ªç¯ + libuvçº¿ç¨‹æ±  |

## 7. æ€»ç»“

### 7.1 æœåŠ¡å™¨æ¶æ„æ¼”è¿›

ä»ç®€å•çš„ä¸²è¡ŒæœåŠ¡å™¨åˆ°é«˜æ€§èƒ½çš„äº‹ä»¶é©±åŠ¨æ¶æ„ï¼ŒæœåŠ¡å™¨æ¶æ„ç»å†äº†ä»¥ä¸‹æ¼”è¿›ï¼š

1. **ä¸²è¡ŒæœåŠ¡å™¨**ï¼šæœ€ç®€å•çš„æ¨¡å‹ï¼Œé€‚åˆå­¦ä¹ 
2. **è¿›ç¨‹/çº¿ç¨‹æ¯è¿æ¥**ï¼šä¸­ç­‰å¹¶å‘ï¼Œèµ„æºæ¶ˆè€—å¤§
3. **è¿›ç¨‹æ± /çº¿ç¨‹æ± **ï¼šé«˜å¹¶å‘ï¼Œèµ„æºå¯æ§
4. **äº‹ä»¶é©±åŠ¨æ¶æ„**ï¼šè¶…é«˜å¹¶å‘ï¼Œèµ„æºå ç”¨ä½

### 7.2 æ¶æ„é€‰æ‹©åŸåˆ™

1. **æ ¹æ®å¹¶å‘é‡é€‰æ‹©**ï¼šä½å¹¶å‘ç”¨ç®€å•æ¨¡å‹ï¼Œé«˜å¹¶å‘ç”¨äº‹ä»¶é©±åŠ¨
2. **æ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©**ï¼šCPUå¯†é›†å‹ç”¨å¤šè¿›ç¨‹/å¤šçº¿ç¨‹ï¼ŒI/Oå¯†é›†å‹ç”¨äº‹ä»¶é©±åŠ¨
3. **æ ¹æ®èµ„æºé™åˆ¶é€‰æ‹©**ï¼šå†…å­˜å……è¶³ç”¨è¿›ç¨‹æ± ï¼Œå†…å­˜å—é™ç”¨çº¿ç¨‹æ± æˆ–äº‹ä»¶é©±åŠ¨
4. **æ ¹æ®å¼€å‘å¤æ‚åº¦é€‰æ‹©**ï¼šç®€å•åº”ç”¨ç”¨çº¿ç¨‹æ± ï¼Œé«˜æ€§èƒ½åº”ç”¨ç”¨äº‹ä»¶é©±åŠ¨

### 7.3 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **ä½¿ç”¨è¿æ¥æ± **ï¼šå‡å°‘è¿æ¥å»ºç«‹å¼€é”€
2. **ä½¿ç”¨éé˜»å¡I/O**ï¼šæé«˜å¹¶å‘èƒ½åŠ›
3. **ä½¿ç”¨I/Oå¤šè·¯å¤ç”¨**ï¼šepoll/kqueueç­‰
4. **ä½¿ç”¨å¼‚æ­¥I/O**ï¼šio_uringç­‰ç°ä»£æ¥å£
5. **ä½¿ç”¨è´Ÿè½½å‡è¡¡**ï¼šæ°´å¹³æ‰©å±•ç³»ç»Ÿèƒ½åŠ›
6. **ä½¿ç”¨ç¼“å­˜**ï¼šå‡å°‘åç«¯å‹åŠ›

### 7.4 æœ€ä½³å®è·µ

1. **ç›‘æ§å’Œæ—¥å¿—**ï¼šå®Œå–„çš„ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ
2. **ä¼˜é›…å…³é—­**ï¼šæ­£ç¡®å¤„ç†ä¿¡å·å’Œèµ„æºæ¸…ç†
3. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
4. **å®‰å…¨è€ƒè™‘**ï¼šè¾“å…¥éªŒè¯ã€æƒé™æ§åˆ¶ã€DDoSé˜²æŠ¤
5. **æ€§èƒ½æµ‹è¯•**ï¼šå®šæœŸè¿›è¡Œå‹åŠ›æµ‹è¯•å’Œæ€§èƒ½è°ƒä¼˜

---

> **ğŸ’¡ æç¤º**ï¼šæœåŠ¡å™¨æ¶æ„è®¾è®¡æ˜¯ä¸€ä¸ªå¤æ‚çš„ä¸»é¢˜ï¼Œéœ€è¦æ ¹æ®å®é™…åº”ç”¨åœºæ™¯é€‰æ‹©åˆé€‚çš„æ¶æ„ã€‚å»ºè®®ä»ç®€å•çš„æ¨¡å‹å¼€å§‹ï¼Œé€æ­¥ä¼˜åŒ–å’Œæ¼”è¿›ï¼Œæœ€ç»ˆè¾¾åˆ°æ€§èƒ½å’Œå¤æ‚åº¦çš„å¹³è¡¡ã€‚

